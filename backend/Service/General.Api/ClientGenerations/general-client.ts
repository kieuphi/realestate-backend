//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class GeneralClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    apiAdmin(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processApiAdmin(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    apiAdminUsersGet(): Observable<UserResult[]> {
        let url_ = this.baseUrl + "/api/admin/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminUsersGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminUsersGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResult[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResult[]>;
        }));
    }

    protected processApiAdminUsersGet(response: HttpResponseBase): Observable<UserResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserResult[];
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResult[]>(null as any);
    }

    apiAdminUsersPost(createUsersRequest: CreateUserModel[]): Observable<CreateUserResult[]> {
        let url_ = this.baseUrl + "/api/admin/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createUsersRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminUsersPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminUsersPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateUserResult[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateUserResult[]>;
        }));
    }

    protected processApiAdminUsersPost(response: HttpResponseBase): Observable<CreateUserResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateUserResult[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateUserResult[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateUserResult[]>(null as any);
    }

    apiAdminGetallinternalaccount(): Observable<UserModel[]> {
        let url_ = this.baseUrl + "/api/admin/getallinternalaccount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminGetallinternalaccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminGetallinternalaccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel[]>;
        }));
    }

    protected processApiAdminGetallinternalaccount(response: HttpResponseBase): Observable<UserModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserModel[];
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserModel[]>(null as any);
    }

    apiAdminGetbyuserid(userId: string | null | undefined): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/admin/getbyuserid?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminGetbyuserid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminGetbyuserid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processApiAdminGetbyuserid(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserModel>(null as any);
    }

    apiAdminCreateinternaluser(createUserProfile: CreateInternalUserModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/admin/createinternaluser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createUserProfile);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminCreateinternaluser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminCreateinternaluser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiAdminCreateinternaluser(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiAdminResendconfirmationaccounttoken(userId: string): Observable<Result> {
        let url_ = this.baseUrl + "/api/admin/resendconfirmationaccounttoken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminResendconfirmationaccounttoken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminResendconfirmationaccounttoken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiAdminResendconfirmationaccounttoken(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateInternalUserModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiAdminUsersResetPassword(userEmails: string[]): Observable<ResetPasswordResult[]> {
        let url_ = this.baseUrl + "/api/admin/users/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userEmails);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminUsersResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminUsersResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResetPasswordResult[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResetPasswordResult[]>;
        }));
    }

    protected processApiAdminUsersResetPassword(response: HttpResponseBase): Observable<ResetPasswordResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResetPasswordResult[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordResult[]>(null as any);
    }

    apiAdminUsersLock(users: string[]): Observable<Result> {
        let url_ = this.baseUrl + "/api/admin/users/lock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(users);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminUsersLock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminUsersLock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiAdminUsersLock(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiAdminUserLock(request: LockUserModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/admin/user/lock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminUserLock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminUserLock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiAdminUserLock(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiAdminUserUnlock(request: LockUserModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/admin/user/unlock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminUserUnlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminUserUnlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiAdminUserUnlock(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiAdminUpdateinternaluser(user: UserModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/admin/updateinternaluser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminUpdateinternaluser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminUpdateinternaluser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiAdminUpdateinternaluser(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiAdminRoles(): Observable<RoleModel[]> {
        let url_ = this.baseUrl + "/api/admin/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleModel[]>;
        }));
    }

    protected processApiAdminRoles(response: HttpResponseBase): Observable<RoleModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleModel[];
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleModel[]>(null as any);
    }

    apiAdminUserVerify(email: string | null): Observable<Result> {
        let url_ = this.baseUrl + "/api/admin/user/verify/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAdminUserVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAdminUserVerify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiAdminUserVerify(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiAttachmenttype(): Observable<AttachmentTypeModel[]> {
        let url_ = this.baseUrl + "/api/attachmenttype";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAttachmenttype(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAttachmenttype(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentTypeModel[]>;
        }));
    }

    protected processApiAttachmenttype(response: HttpResponseBase): Observable<AttachmentTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttachmentTypeModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentTypeModel[]>(null as any);
    }

    apiAttachmenttypeDetail(id: string): Observable<AttachmentTypeModel> {
        let url_ = this.baseUrl + "/api/attachmenttype/detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiAttachmenttypeDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiAttachmenttypeDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentTypeModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentTypeModel>;
        }));
    }

    protected processApiAttachmenttypeDetail(response: HttpResponseBase): Observable<AttachmentTypeModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttachmentTypeModel;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttachmentTypeModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentTypeModel>(null as any);
    }

    apiBannerCreate(model: CreateBannerModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/banner/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBannerCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBannerCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiBannerCreate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiBannerGetbyid(id: string): Observable<BannerModel> {
        let url_ = this.baseUrl + "/api/banner/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBannerGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBannerGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BannerModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BannerModel>;
        }));
    }

    protected processApiBannerGetbyid(response: HttpResponseBase): Observable<BannerModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BannerModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BannerModel>(null as any);
    }

    apiBannerGetall(): Observable<BannerModel[]> {
        let url_ = this.baseUrl + "/api/banner/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBannerGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBannerGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BannerModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BannerModel[]>;
        }));
    }

    protected processApiBannerGetall(response: HttpResponseBase): Observable<BannerModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BannerModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BannerModel[]>(null as any);
    }

    apiBannerDelete(id: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/banner/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBannerDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBannerDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiBannerDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiBannerGetpaging(model: PagingBannerModel): Observable<PaginatedListOfBannerModel> {
        let url_ = this.baseUrl + "/api/banner/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBannerGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBannerGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfBannerModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfBannerModel>;
        }));
    }

    protected processApiBannerGetpaging(response: HttpResponseBase): Observable<PaginatedListOfBannerModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfBannerModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfBannerModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfBannerModel>(null as any);
    }

    apiBannerUpdate(bannerId: string | undefined, model: CreateBannerModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/banner/update?";
        if (bannerId === null)
            throw new Error("The parameter 'bannerId' cannot be null.");
        else if (bannerId !== undefined)
            url_ += "bannerId=" + encodeURIComponent("" + bannerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBannerUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBannerUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiBannerUpdate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiBannerGetbytype(type: BannerTypes | undefined): Observable<BannerModel[]> {
        let url_ = this.baseUrl + "/api/banner/getbytype?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiBannerGetbytype(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiBannerGetbytype(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BannerModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BannerModel[]>;
        }));
    }

    protected processApiBannerGetbytype(response: HttpResponseBase): Observable<BannerModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BannerModel[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BannerModel[]>(null as any);
    }

    apiConfigSave(model: CreateConfigModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/config/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiConfigSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiConfigSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiConfigSave(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiConfigGetconfig(): Observable<ConfigModel> {
        let url_ = this.baseUrl + "/api/config/getconfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiConfigGetconfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiConfigGetconfig(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConfigModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConfigModel>;
        }));
    }

    protected processApiConfigGetconfig(response: HttpResponseBase): Observable<ConfigModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ConfigModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigModel>(null as any);
    }

    apiContactCreate(model: CreateContactModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/contact/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiContactCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiContactCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiContactCreate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiContactGetbyid(id: string): Observable<ContactModel> {
        let url_ = this.baseUrl + "/api/contact/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiContactGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiContactGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactModel>;
        }));
    }

    protected processApiContactGetbyid(response: HttpResponseBase): Observable<ContactModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ContactModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactModel>(null as any);
    }

    apiContactGetall(): Observable<ContactModel[]> {
        let url_ = this.baseUrl + "/api/contact/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiContactGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiContactGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactModel[]>;
        }));
    }

    protected processApiContactGetall(response: HttpResponseBase): Observable<ContactModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ContactModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactModel[]>(null as any);
    }

    apiContactDelete(contactId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/contact/delete?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiContactDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiContactDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiContactDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiContactUpdate(contactId: string | undefined, model: CreateContactModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/contact/update?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiContactUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiContactUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiContactUpdate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiContactGetpaging(pagingModel: PagingContactModel): Observable<PaginatedListOfContactModel> {
        let url_ = this.baseUrl + "/api/contact/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiContactGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiContactGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfContactModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfContactModel>;
        }));
    }

    protected processApiContactGetpaging(response: HttpResponseBase): Observable<PaginatedListOfContactModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfContactModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfContactModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfContactModel>(null as any);
    }

    apiHealth(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiHealth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiHealth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processApiHealth(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    apiImagecategory(): Observable<ImageCategoryModel[]> {
        let url_ = this.baseUrl + "/api/imagecategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiImagecategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiImagecategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImageCategoryModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImageCategoryModel[]>;
        }));
    }

    protected processApiImagecategory(response: HttpResponseBase): Observable<ImageCategoryModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ImageCategoryModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImageCategoryModel[]>(null as any);
    }

    apiMapGetprovinces(): Observable<any> {
        let url_ = this.baseUrl + "/api/map/getprovinces";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMapGetprovinces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMapGetprovinces(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processApiMapGetprovinces(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    apiMapGetdistricts(): Observable<any> {
        let url_ = this.baseUrl + "/api/map/getdistricts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMapGetdistricts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMapGetdistricts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processApiMapGetdistricts(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    apiMapGetwards(): Observable<any> {
        let url_ = this.baseUrl + "/api/map/getwards";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMapGetwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMapGetwards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processApiMapGetwards(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    apiMapFilterdisctrict(provinceCode: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/map/filterdisctrict?";
        if (provinceCode !== undefined && provinceCode !== null)
            url_ += "provinceCode=" + encodeURIComponent("" + provinceCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMapFilterdisctrict(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMapFilterdisctrict(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processApiMapFilterdisctrict(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    apiMapFilterward(districtCode: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/map/filterward?";
        if (districtCode !== undefined && districtCode !== null)
            url_ += "districtCode=" + encodeURIComponent("" + districtCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMapFilterward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMapFilterward(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processApiMapFilterward(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    apiMapGetcoordinateprovincebycode(code: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/map/getcoordinateprovincebycode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMapGetcoordinateprovincebycode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMapGetcoordinateprovincebycode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processApiMapGetcoordinateprovincebycode(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    apiMapGetcoordinatedistrictbycode(code: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/map/getcoordinatedistrictbycode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMapGetcoordinatedistrictbycode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMapGetcoordinatedistrictbycode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processApiMapGetcoordinatedistrictbycode(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    apiMapGetcoordinatewardbycode(code: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/map/getcoordinatewardbycode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMapGetcoordinatewardbycode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMapGetcoordinatewardbycode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processApiMapGetcoordinatewardbycode(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    apiMapGetcoordinateprovincebyname(nameWithType: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/map/getcoordinateprovincebyname?";
        if (nameWithType !== undefined && nameWithType !== null)
            url_ += "nameWithType=" + encodeURIComponent("" + nameWithType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMapGetcoordinateprovincebyname(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMapGetcoordinateprovincebyname(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processApiMapGetcoordinateprovincebyname(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    apiMapGetcoordinatedistrictbyname(nameWithType: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/map/getcoordinatedistrictbyname?";
        if (nameWithType !== undefined && nameWithType !== null)
            url_ += "nameWithType=" + encodeURIComponent("" + nameWithType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMapGetcoordinatedistrictbyname(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMapGetcoordinatedistrictbyname(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processApiMapGetcoordinatedistrictbyname(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    apiMapGetcoordinatewardbyname(nameWithType: string | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/map/getcoordinatewardbyname?";
        if (nameWithType !== undefined && nameWithType !== null)
            url_ += "nameWithType=" + encodeURIComponent("" + nameWithType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMapGetcoordinatewardbyname(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMapGetcoordinatewardbyname(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processApiMapGetcoordinatewardbyname(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    apiMasterdataGetmasterdata(): Observable<any> {
        let url_ = this.baseUrl + "/api/masterdata/getmasterdata";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMasterdataGetmasterdata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMasterdataGetmasterdata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processApiMasterdataGetmasterdata(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(null as any);
    }

    apiMasterdataGetpropertytypebytransaction(transactionId: string | null | undefined): Observable<PropertyTypeModel[]> {
        let url_ = this.baseUrl + "/api/masterdata/getpropertytypebytransaction?";
        if (transactionId !== undefined && transactionId !== null)
            url_ += "transactionId=" + encodeURIComponent("" + transactionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiMasterdataGetpropertytypebytransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiMasterdataGetpropertytypebytransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PropertyTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PropertyTypeModel[]>;
        }));
    }

    protected processApiMasterdataGetpropertytypebytransaction(response: HttpResponseBase): Observable<PropertyTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PropertyTypeModel[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyTypeModel[]>(null as any);
    }

    apiNewscategoryCreate(model: CreateNewsCategoryModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/newscategory/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategoryCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategoryCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewscategoryCreate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewscategoryGetbyid(id: string): Observable<NewsCategoryModel> {
        let url_ = this.baseUrl + "/api/newscategory/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategoryGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategoryGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NewsCategoryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NewsCategoryModel>;
        }));
    }

    protected processApiNewscategoryGetbyid(response: HttpResponseBase): Observable<NewsCategoryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NewsCategoryModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NewsCategoryModel>(null as any);
    }

    apiNewscategoryGetall(): Observable<ListNewsCategoryModel[]> {
        let url_ = this.baseUrl + "/api/newscategory/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategoryGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategoryGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListNewsCategoryModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListNewsCategoryModel[]>;
        }));
    }

    protected processApiNewscategoryGetall(response: HttpResponseBase): Observable<ListNewsCategoryModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ListNewsCategoryModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListNewsCategoryModel[]>(null as any);
    }

    apiNewscategoryDelete(newsCategoryId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/newscategory/delete?";
        if (newsCategoryId === null)
            throw new Error("The parameter 'newsCategoryId' cannot be null.");
        else if (newsCategoryId !== undefined)
            url_ += "newsCategoryId=" + encodeURIComponent("" + newsCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategoryDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategoryDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewscategoryDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewscategoryUpdate(newsCategoryId: string | undefined, model: CreateNewsCategoryModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/newscategory/update?";
        if (newsCategoryId === null)
            throw new Error("The parameter 'newsCategoryId' cannot be null.");
        else if (newsCategoryId !== undefined)
            url_ += "newsCategoryId=" + encodeURIComponent("" + newsCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategoryUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategoryUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewscategoryUpdate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewscategoryGetpaging(pagingModel: PagingNewsCategoryModel): Observable<PaginatedListOfListNewsCategoryModel> {
        let url_ = this.baseUrl + "/api/newscategory/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategoryGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategoryGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListNewsCategoryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListNewsCategoryModel>;
        }));
    }

    protected processApiNewscategoryGetpaging(response: HttpResponseBase): Observable<PaginatedListOfListNewsCategoryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsCategoryModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsCategoryModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListNewsCategoryModel>(null as any);
    }

    apiNewscategorySearchingforadmin(model: SearchingNewsCategoryModel): Observable<PaginatedListOfListNewsCategoryModel> {
        let url_ = this.baseUrl + "/api/newscategory/searchingforadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategorySearchingforadmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategorySearchingforadmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListNewsCategoryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListNewsCategoryModel>;
        }));
    }

    protected processApiNewscategorySearchingforadmin(response: HttpResponseBase): Observable<PaginatedListOfListNewsCategoryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsCategoryModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsCategoryModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListNewsCategoryModel>(null as any);
    }

    apiNewscategoryPost(newsCategoryId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/newscategory/post?";
        if (newsCategoryId === null)
            throw new Error("The parameter 'newsCategoryId' cannot be null.");
        else if (newsCategoryId !== undefined)
            url_ += "newsCategoryId=" + encodeURIComponent("" + newsCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategoryPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategoryPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewscategoryPost(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewscategoryUnpost(newsCategoryId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/newscategory/unpost?";
        if (newsCategoryId === null)
            throw new Error("The parameter 'newsCategoryId' cannot be null.");
        else if (newsCategoryId !== undefined)
            url_ += "newsCategoryId=" + encodeURIComponent("" + newsCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategoryUnpost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategoryUnpost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewscategoryUnpost(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewscategoryActive(id: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/newscategory/active?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategoryActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategoryActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewscategoryActive(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewscategoryInactive(id: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/newscategory/inactive?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategoryInactive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategoryInactive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewscategoryInactive(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewscategoryLock(id: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/newscategory/lock?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategoryLock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategoryLock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewscategoryLock(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewscategoryUnlock(newsCategoryId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/newscategory/unlock?";
        if (newsCategoryId === null)
            throw new Error("The parameter 'newsCategoryId' cannot be null.");
        else if (newsCategoryId !== undefined)
            url_ += "newsCategoryId=" + encodeURIComponent("" + newsCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewscategoryUnlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewscategoryUnlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewscategoryUnlock(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewsCreate(model: CreateNewsModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/news/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewsCreate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewsGetbyid(id: string): Observable<NewsModel> {
        let url_ = this.baseUrl + "/api/news/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NewsModel>;
        }));
    }

    protected processApiNewsGetbyid(response: HttpResponseBase): Observable<NewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NewsModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NewsModel>(null as any);
    }

    apiNewsGetall(): Observable<ListNewsModel[]> {
        let url_ = this.baseUrl + "/api/news/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListNewsModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListNewsModel[]>;
        }));
    }

    protected processApiNewsGetall(response: HttpResponseBase): Observable<ListNewsModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ListNewsModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListNewsModel[]>(null as any);
    }

    apiNewsDelete(newsId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/news/delete?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewsDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewsUpdate(newsId: string | undefined, model: CreateNewsModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/news/update?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewsUpdate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewsGetpaging(pagingModel: PagingNewsModel): Observable<PaginatedListOfListNewsModel> {
        let url_ = this.baseUrl + "/api/news/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListNewsModel>;
        }));
    }

    protected processApiNewsGetpaging(response: HttpResponseBase): Observable<PaginatedListOfListNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListNewsModel>(null as any);
    }

    apiNewsSearching(model: SearchingNewsModel): Observable<PaginatedListOfListNewsModel> {
        let url_ = this.baseUrl + "/api/news/searching";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsSearching(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsSearching(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListNewsModel>;
        }));
    }

    protected processApiNewsSearching(response: HttpResponseBase): Observable<PaginatedListOfListNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListNewsModel>(null as any);
    }

    apiNewsSearchingforadmin(model: SearchingNewsForAdminModel): Observable<PaginatedListOfListNewsModel> {
        let url_ = this.baseUrl + "/api/news/searchingforadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsSearchingforadmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsSearchingforadmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListNewsModel>;
        }));
    }

    protected processApiNewsSearchingforadmin(response: HttpResponseBase): Observable<PaginatedListOfListNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListNewsModel>(null as any);
    }

    apiNewsPost(newsId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/news/post?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewsPost(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewsUnpost(newsId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/news/unpost?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsUnpost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsUnpost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewsUnpost(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewsUnlock(newsId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/news/unlock?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsUnlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsUnlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewsUnlock(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewsGethotnews(pagingModel: PagingNewsModel): Observable<PaginatedListOfListNewsModel> {
        let url_ = this.baseUrl + "/api/news/gethotnews";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsGethotnews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsGethotnews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListNewsModel>;
        }));
    }

    protected processApiNewsGethotnews(response: HttpResponseBase): Observable<PaginatedListOfListNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListNewsModel>(null as any);
    }

    apiNewsGewellreadnews(pagingModel: PagingNewsModel): Observable<PaginatedListOfListNewsModel> {
        let url_ = this.baseUrl + "/api/news/gewellreadnews";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsGewellreadnews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsGewellreadnews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListNewsModel>;
        }));
    }

    protected processApiNewsGewellreadnews(response: HttpResponseBase): Observable<PaginatedListOfListNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListNewsModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListNewsModel>(null as any);
    }

    apiNewsGetnewsgroupbycategory(): Observable<ListNewsGroupByCategoryModel[]> {
        let url_ = this.baseUrl + "/api/news/getnewsgroupbycategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsGetnewsgroupbycategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsGetnewsgroupbycategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListNewsGroupByCategoryModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListNewsGroupByCategoryModel[]>;
        }));
    }

    protected processApiNewsGetnewsgroupbycategory(response: HttpResponseBase): Observable<ListNewsGroupByCategoryModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ListNewsGroupByCategoryModel[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ListNewsGroupByCategoryModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListNewsGroupByCategoryModel[]>(null as any);
    }

    apiNewsGetbycategoryid(categoryId: string, pagingModel: PagingNewsModel): Observable<PaginatedListOfNewsModel> {
        let url_ = this.baseUrl + "/api/news/getbycategoryid/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsGetbycategoryid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsGetbycategoryid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfNewsModel>;
        }));
    }

    protected processApiNewsGetbycategoryid(response: HttpResponseBase): Observable<PaginatedListOfNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfNewsModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfNewsModel>(null as any);
    }

    apiNewsCountviewnews(newsId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/news/countviewnews?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsCountviewnews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsCountviewnews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNewsCountviewnews(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNewsGetnextnews(currentNewsId: string): Observable<ListNewsModel> {
        let url_ = this.baseUrl + "/api/news/getnextnews/{currentNewsId}";
        if (currentNewsId === undefined || currentNewsId === null)
            throw new Error("The parameter 'currentNewsId' must be defined.");
        url_ = url_.replace("{currentNewsId}", encodeURIComponent("" + currentNewsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNewsGetnextnews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNewsGetnextnews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListNewsModel>;
        }));
    }

    protected processApiNewsGetnextnews(response: HttpResponseBase): Observable<ListNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ListNewsModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ListNewsModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListNewsModel>(null as any);
    }

    apiNotificationGetpaging(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfNotificationModel> {
        let url_ = this.baseUrl + "/api/notification/getpaging?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfNotificationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfNotificationModel>;
        }));
    }

    protected processApiNotificationGetpaging(response: HttpResponseBase): Observable<PaginatedListOfNotificationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfNotificationModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfNotificationModel>(null as any);
    }

    apiNotificationGetbyid(id: string | undefined): Observable<NotificationModel> {
        let url_ = this.baseUrl + "/api/notification/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationModel>;
        }));
    }

    protected processApiNotificationGetbyid(response: HttpResponseBase): Observable<NotificationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotificationModel;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FileResponse;
            return throwException("A server side error occurred.", status, _responseText, _headers, result204);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationModel>(null as any);
    }

    apiNotificationCreate(model: CreateNotificationModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/notification/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNotificationCreate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateNotificationModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNotificationFilter(filterNotificationModel: FilterNotificationModel): Observable<PaginatedListOfNotificationModel> {
        let url_ = this.baseUrl + "/api/notification/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterNotificationModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfNotificationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfNotificationModel>;
        }));
    }

    protected processApiNotificationFilter(response: HttpResponseBase): Observable<PaginatedListOfNotificationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SortingNotificationModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfNotificationModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfNotificationModel>(null as any);
    }

    apiNotificationUpdate(id: string | undefined, updateNotificationModel: UpdateNotificationModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/notification/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateNotificationModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNotificationUpdate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateNotificationModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNotificationPostnotification(id: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/notification/postnotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationPostnotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationPostnotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNotificationPostnotification(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateNotificationModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNotificationUnpostnotification(id: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/notification/unpostnotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationUnpostnotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationUnpostnotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNotificationUnpostnotification(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UpdateNotificationModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNotificationGetpagingbyuser(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfNotificationUserModel> {
        let url_ = this.baseUrl + "/api/notification/getpagingbyuser?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationGetpagingbyuser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationGetpagingbyuser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfNotificationUserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfNotificationUserModel>;
        }));
    }

    protected processApiNotificationGetpagingbyuser(response: HttpResponseBase): Observable<PaginatedListOfNotificationUserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfNotificationUserModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfNotificationUserModel>(null as any);
    }

    apiNotificationGetcountnotificationbyuser(isSeen: boolean | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/notification/getcountnotificationbyuser?";
        if (isSeen !== undefined && isSeen !== null)
            url_ += "IsSeen=" + encodeURIComponent("" + isSeen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationGetcountnotificationbyuser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationGetcountnotificationbyuser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processApiNotificationGetcountnotificationbyuser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    apiNotificationRemovenotificationbyuser(id: string): Observable<Result> {
        let url_ = this.baseUrl + "/api/notification/removenotificationbyuser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(id);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationRemovenotificationbyuser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationRemovenotificationbyuser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNotificationRemovenotificationbyuser(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateNotificationModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNotificationRemoveallnotificationbyuser(): Observable<Result> {
        let url_ = this.baseUrl + "/api/notification/removeallnotificationbyuser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationRemoveallnotificationbyuser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationRemoveallnotificationbyuser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNotificationRemoveallnotificationbyuser(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateNotificationModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiNotificationSeennotificationbyuser(listId: string[]): Observable<Result> {
        let url_ = this.baseUrl + "/api/notification/seennotificationbyuser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiNotificationSeennotificationbyuser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiNotificationSeennotificationbyuser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiNotificationSeennotificationbyuser(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateNotificationModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPhotoMultipleGet(attachmentType: string | null | undefined): Observable<AttachmentModel[]> {
        let url_ = this.baseUrl + "/api/photo/multiple?";
        if (attachmentType !== undefined && attachmentType !== null)
            url_ += "attachmentType=" + encodeURIComponent("" + attachmentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPhotoMultipleGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPhotoMultipleGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentModel[]>;
        }));
    }

    protected processApiPhotoMultipleGet(response: HttpResponseBase): Observable<AttachmentModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttachmentModel[];
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttachmentModel[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttachmentModel[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentModel[]>(null as any);
    }

    apiPhotoMultiplePost(files: FileParameter[] | null | undefined, attachmentType: string | null | undefined, referenceId: string | null | undefined, imageCategory: string | null | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/photo/multiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("Files", item_.data, item_.fileName ? item_.fileName : "Files") );
        if (attachmentType !== null && attachmentType !== undefined)
            content_.append("AttachmentType", attachmentType.toString());
        if (referenceId !== null && referenceId !== undefined)
            content_.append("ReferenceId", referenceId.toString());
        if (imageCategory !== null && imageCategory !== undefined)
            content_.append("ImageCategory", imageCategory.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPhotoMultiplePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPhotoMultiplePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPhotoMultiplePost(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPhotoGetimagesbyfilter(attachmentCollectionFilter: AttachmentCollectionFilterModel): Observable<AttachmentModel[]> {
        let url_ = this.baseUrl + "/api/photo/getimagesbyfilter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(attachmentCollectionFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPhotoGetimagesbyfilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPhotoGetimagesbyfilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentModel[]>;
        }));
    }

    protected processApiPhotoGetimagesbyfilter(response: HttpResponseBase): Observable<AttachmentModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttachmentModel[];
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttachmentModel[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttachmentModel[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentModel[]>(null as any);
    }

    apiPhotoSingleGet(fileId: string, attachmentType: string | null | undefined): Observable<AttachmentModel[]> {
        let url_ = this.baseUrl + "/api/photo/single/{fileId}?";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        if (attachmentType !== undefined && attachmentType !== null)
            url_ += "attachmentType=" + encodeURIComponent("" + attachmentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPhotoSingleGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPhotoSingleGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentModel[]>;
        }));
    }

    protected processApiPhotoSingleGet(response: HttpResponseBase): Observable<AttachmentModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttachmentModel[];
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttachmentModel[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttachmentModel[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachmentModel[]>(null as any);
    }

    apiPhotoSingleDelete(fileId: string, attachmentType: string | null | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/photo/single/{fileId}?";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        if (attachmentType !== undefined && attachmentType !== null)
            url_ += "attachmentType=" + encodeURIComponent("" + attachmentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPhotoSingleDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPhotoSingleDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPhotoSingleDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPhotoSinglePost(file: FileParameter | null | undefined, attachmentType: string | null | undefined, referenceId: string | null | undefined, imageCategory: string | null | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/photo/single";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (attachmentType !== null && attachmentType !== undefined)
            content_.append("AttachmentType", attachmentType.toString());
        if (referenceId !== null && referenceId !== undefined)
            content_.append("ReferenceId", referenceId.toString());
        if (imageCategory !== null && imageCategory !== undefined)
            content_.append("ImageCategory", imageCategory.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPhotoSinglePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPhotoSinglePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPhotoSinglePost(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UploadMultipleFileRequestModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiProfileChangePassword(request: ChangePasswordModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/profile/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProfileChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProfileChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiProfileChangePassword(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiProfileUpdateProfile(request: UpdateProfileModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/profile/update-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProfileUpdateProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProfileUpdateProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiProfileUpdateProfile(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiProfileForgetPassword(request: ForgetPasswordModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/profile/forget-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProfileForgetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProfileForgetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiProfileForgetPassword(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiProfileProfile(userName: string | null | undefined): Observable<UserResult> {
        let url_ = this.baseUrl + "/api/profile/profile?";
        if (userName !== undefined && userName !== null)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProfileProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProfileProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResult>;
        }));
    }

    protected processApiProfileProfile(response: HttpResponseBase): Observable<UserResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResult>(null as any);
    }

    apiProfileInfo(): Observable<UserResult> {
        let url_ = this.baseUrl + "/api/profile/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProfileInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProfileInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserResult>;
        }));
    }

    protected processApiProfileInfo(response: HttpResponseBase): Observable<UserResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserResult>(null as any);
    }

    apiProjectCreate(model: CreateProjectModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/project/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiProjectCreate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiProjectGetbyid(id: string): Observable<ProjectModel> {
        let url_ = this.baseUrl + "/api/project/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectModel>;
        }));
    }

    protected processApiProjectGetbyid(response: HttpResponseBase): Observable<ProjectModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProjectModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectModel>(null as any);
    }

    apiProjectGetall(): Observable<ProjectModel[]> {
        let url_ = this.baseUrl + "/api/project/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectModel[]>;
        }));
    }

    protected processApiProjectGetall(response: HttpResponseBase): Observable<ProjectModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProjectModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectModel[]>(null as any);
    }

    apiProjectDelete(projectId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/project/delete?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiProjectDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiProjectUpdate(projectId: string | undefined, model: UpdateProjectModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/project/update?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiProjectUpdate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiProjectGetpaging(pagingModel: PagingProjectModel): Observable<PaginatedListOfProjectModel> {
        let url_ = this.baseUrl + "/api/project/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProjectModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProjectModel>;
        }));
    }

    protected processApiProjectGetpaging(response: HttpResponseBase): Observable<PaginatedListOfProjectModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfProjectModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfProjectModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfProjectModel>(null as any);
    }

    apiProjectSearch(model: SearchProjectModel): Observable<PaginatedListOfProjectModel> {
        let url_ = this.baseUrl + "/api/project/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProjectModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProjectModel>;
        }));
    }

    protected processApiProjectSearch(response: HttpResponseBase): Observable<PaginatedListOfProjectModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfProjectModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfProjectModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfProjectModel>(null as any);
    }

    apiProjectCountviewproject(projectId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/project/countviewproject?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectCountviewproject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectCountviewproject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiProjectCountviewproject(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiProjectGetadministrativebyproject(): Observable<AdministrativeByProjectModel[]> {
        let url_ = this.baseUrl + "/api/project/getadministrativebyproject";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectGetadministrativebyproject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectGetadministrativebyproject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdministrativeByProjectModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdministrativeByProjectModel[]>;
        }));
    }

    protected processApiProjectGetadministrativebyproject(response: HttpResponseBase): Observable<AdministrativeByProjectModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AdministrativeByProjectModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdministrativeByProjectModel[]>(null as any);
    }

    apiProjectSuggestproject(keyword: string | null | undefined): Observable<SuggestSearchProjectModel[]> {
        let url_ = this.baseUrl + "/api/project/suggestproject?";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectSuggestproject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectSuggestproject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SuggestSearchProjectModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SuggestSearchProjectModel[]>;
        }));
    }

    protected processApiProjectSuggestproject(response: HttpResponseBase): Observable<SuggestSearchProjectModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SuggestSearchProjectModel[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SuggestSearchProjectModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SuggestSearchProjectModel[]>(null as any);
    }

    apiProjectPost(projectId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/project/post?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiProjectPost(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiProjectUnpost(projectId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/project/unpost?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectUnpost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectUnpost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiProjectUnpost(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiProjectUnlock(projectId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/project/unlock?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectUnlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectUnlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiProjectUnlock(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiProjectSearchforadmin(model: SearchProjectForAdminModel): Observable<PaginatedListOfProjectModel> {
        let url_ = this.baseUrl + "/api/project/searchforadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiProjectSearchforadmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiProjectSearchforadmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProjectModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProjectModel>;
        }));
    }

    protected processApiProjectSearchforadmin(response: HttpResponseBase): Observable<PaginatedListOfProjectModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfProjectModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfProjectModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfProjectModel>(null as any);
    }

    apiPropertyCreate(model: CreatePropertyModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/property/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyCreate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertySavetemp(model: CreatePropertyModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/property/savetemp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertySavetemp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertySavetemp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertySavetemp(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertyGetall(): Observable<ListPropertyModel[]> {
        let url_ = this.baseUrl + "/api/property/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListPropertyModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListPropertyModel[]>;
        }));
    }

    protected processApiPropertyGetall(response: HttpResponseBase): Observable<ListPropertyModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ListPropertyModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListPropertyModel[]>(null as any);
    }

    apiPropertyFilterpropertybyuser(filterData: FilterPropertyByUserModel): Observable<ListPropertyModel[]> {
        let url_ = this.baseUrl + "/api/property/filterpropertybyuser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyFilterpropertybyuser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyFilterpropertybyuser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListPropertyModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListPropertyModel[]>;
        }));
    }

    protected processApiPropertyFilterpropertybyuser(response: HttpResponseBase): Observable<ListPropertyModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ListPropertyModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListPropertyModel[]>(null as any);
    }

    apiPropertyGetallbasicinfo(): Observable<BasicPropertyModel[]> {
        let url_ = this.baseUrl + "/api/property/getallbasicinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyGetallbasicinfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyGetallbasicinfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasicPropertyModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasicPropertyModel[]>;
        }));
    }

    protected processApiPropertyGetallbasicinfo(response: HttpResponseBase): Observable<BasicPropertyModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BasicPropertyModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BasicPropertyModel[]>(null as any);
    }

    apiPropertyGetbyid(id: string): Observable<PropertyModel> {
        let url_ = this.baseUrl + "/api/property/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PropertyModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PropertyModel>;
        }));
    }

    protected processApiPropertyGetbyid(response: HttpResponseBase): Observable<PropertyModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PropertyModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyModel>(null as any);
    }

    apiPropertyGetbyidadmin(id: string | undefined): Observable<PropertyModel> {
        let url_ = this.baseUrl + "/api/property/getbyidadmin?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyGetbyidadmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyGetbyidadmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PropertyModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PropertyModel>;
        }));
    }

    protected processApiPropertyGetbyidadmin(response: HttpResponseBase): Observable<PropertyModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PropertyModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyModel>(null as any);
    }

    apiPropertyGetbylistid(listId: string[]): Observable<PropertyModel> {
        let url_ = this.baseUrl + "/api/property/getbylistid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyGetbylistid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyGetbylistid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PropertyModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PropertyModel>;
        }));
    }

    protected processApiPropertyGetbylistid(response: HttpResponseBase): Observable<PropertyModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PropertyModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyModel>(null as any);
    }

    apiPropertyUpdate(propertyId: string | undefined, model: UpdatePropertyModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/property/update?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyUpdate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertyUpdatepropertybyuser(propertyId: string | undefined, model: CreatePropertyModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/property/updatepropertybyuser?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyUpdatepropertybyuser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyUpdatepropertybyuser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyUpdatepropertybyuser(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertyViewproperty(propertyId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/property/viewproperty?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyViewproperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyViewproperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyViewproperty(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertyApprove(model: ApprovePropertyModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/property/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyApprove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyApprove(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertyDelete(propertyId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/property/delete?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertyDeletetempproperty(propertyId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/property/deletetempproperty?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyDeletetempproperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyDeletetempproperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyDeletetempproperty(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertySearch(searchModel: SearchingPropertyModel): Observable<PaginatedListOfListPropertyModel> {
        let url_ = this.baseUrl + "/api/property/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertySearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertySearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListPropertyModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListPropertyModel>;
        }));
    }

    protected processApiPropertySearch(response: HttpResponseBase): Observable<PaginatedListOfListPropertyModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListPropertyModel>(null as any);
    }

    apiPropertySearchforadmin(searchModel: SearchingPropertyForAdminModel): Observable<PaginatedListOfListPropertyModel> {
        let url_ = this.baseUrl + "/api/property/searchforadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertySearchforadmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertySearchforadmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListPropertyModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListPropertyModel>;
        }));
    }

    protected processApiPropertySearchforadmin(response: HttpResponseBase): Observable<PaginatedListOfListPropertyModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListPropertyModel>(null as any);
    }

    apiPropertySuggestproperty(keyword: string | null | undefined): Observable<SuggestSearchPropertyModel> {
        let url_ = this.baseUrl + "/api/property/suggestproperty?";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertySuggestproperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertySuggestproperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SuggestSearchPropertyModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SuggestSearchPropertyModel>;
        }));
    }

    protected processApiPropertySuggestproperty(response: HttpResponseBase): Observable<SuggestSearchPropertyModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SuggestSearchPropertyModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SuggestSearchPropertyModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SuggestSearchPropertyModel>(null as any);
    }

    apiPropertyGettotalcount(): Observable<number> {
        let url_ = this.baseUrl + "/api/property/gettotalcount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyGettotalcount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyGettotalcount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processApiPropertyGettotalcount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    apiPropertyGetnearest(model: PagingNearestPropertyModel): Observable<PaginatedListOfListPropertyModel> {
        let url_ = this.baseUrl + "/api/property/getnearest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyGetnearest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyGetnearest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListPropertyModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListPropertyModel>;
        }));
    }

    protected processApiPropertyGetnearest(response: HttpResponseBase): Observable<PaginatedListOfListPropertyModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListPropertyModel>(null as any);
    }

    apiPropertyGetpaging(pagingModel: PagingPropertyModel): Observable<PaginatedListOfListPropertyModel> {
        let url_ = this.baseUrl + "/api/property/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListPropertyModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListPropertyModel>;
        }));
    }

    protected processApiPropertyGetpaging(response: HttpResponseBase): Observable<PaginatedListOfListPropertyModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListPropertyModel>(null as any);
    }

    apiPropertyUnpost(propertyId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/property/unpost?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyUnpost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyUnpost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyUnpost(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertyUnlock(propertyId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/property/unlock?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyUnlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyUnlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyUnlock(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertyfavoriteCreate(model: CreatePropertyFavoriteModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/propertyfavorite/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyfavoriteCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyfavoriteCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyfavoriteCreate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertyfavoriteGetpaging(model: PagingPropertyFavoriteModel): Observable<PaginatedListOfListPropertyModel> {
        let url_ = this.baseUrl + "/api/propertyfavorite/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyfavoriteGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyfavoriteGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListPropertyModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListPropertyModel>;
        }));
    }

    protected processApiPropertyfavoriteGetpaging(response: HttpResponseBase): Observable<PaginatedListOfListPropertyModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListPropertyModel>(null as any);
    }

    apiPropertyfavoriteDelete(propertyFavoriteId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/propertyfavorite/delete?";
        if (propertyFavoriteId === null)
            throw new Error("The parameter 'propertyFavoriteId' cannot be null.");
        else if (propertyFavoriteId !== undefined)
            url_ += "propertyFavoriteId=" + encodeURIComponent("" + propertyFavoriteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyfavoriteDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyfavoriteDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyfavoriteDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertyheartSendheart(model: CreatePropertyHeartModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/propertyheart/sendheart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyheartSendheart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyheartSendheart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyheartSendheart(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertyheartGetpaging(model: PagingPropertyHeartModel): Observable<PaginatedListOfListPropertyHeartModel> {
        let url_ = this.baseUrl + "/api/propertyheart/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyheartGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyheartGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListPropertyHeartModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListPropertyHeartModel>;
        }));
    }

    protected processApiPropertyheartGetpaging(response: HttpResponseBase): Observable<PaginatedListOfListPropertyHeartModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PagingPropertyHeartModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyHeartModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListPropertyHeartModel>(null as any);
    }

    apiPropertyheartDelete(propertyHeartId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/propertyheart/delete?";
        if (propertyHeartId === null)
            throw new Error("The parameter 'propertyHeartId' cannot be null.");
        else if (propertyHeartId !== undefined)
            url_ += "propertyHeartId=" + encodeURIComponent("" + propertyHeartId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyheartDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyheartDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertyheartDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertyheartIspropertyheart(model: CreatePropertyHeartModel): Observable<boolean> {
        let url_ = this.baseUrl + "/api/propertyheart/ispropertyheart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyheartIspropertyheart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyheartIspropertyheart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processApiPropertyheartIspropertyheart(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    apiPropertyheartIsmanypropertyheart(userId: string, propertyIds: string[]): Observable<boolean[]> {
        let url_ = this.baseUrl + "/api/propertyheart/ismanypropertyheart/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(propertyIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertyheartIsmanypropertyheart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertyheartIsmanypropertyheart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean[]>;
        }));
    }

    protected processApiPropertyheartIsmanypropertyheart(response: HttpResponseBase): Observable<boolean[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean[];
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean[]>(null as any);
    }

    apiPropertymeetingnoteGetbyid(propertyId: string): Observable<PropertyMeetingNoteModel> {
        let url_ = this.baseUrl + "/api/propertymeetingnote/getbyid/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertymeetingnoteGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertymeetingnoteGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PropertyMeetingNoteModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PropertyMeetingNoteModel>;
        }));
    }

    protected processApiPropertymeetingnoteGetbyid(response: HttpResponseBase): Observable<PropertyMeetingNoteModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PropertyMeetingNoteModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyMeetingNoteModel>(null as any);
    }

    apiPropertynearestCreate(model: CreatePropertyNearestModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/propertynearest/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertynearestCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertynearestCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertynearestCreate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiPropertynearestGetpaging(model: PagingPropertyNearestModel): Observable<PaginatedListOfListPropertyModel> {
        let url_ = this.baseUrl + "/api/propertynearest/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertynearestGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertynearestGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfListPropertyModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfListPropertyModel>;
        }));
    }

    protected processApiPropertynearestGetpaging(response: HttpResponseBase): Observable<PaginatedListOfListPropertyModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfListPropertyModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfListPropertyModel>(null as any);
    }

    apiPropertynearestDelete(propertyNearestId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/propertynearest/delete?";
        if (propertyNearestId === null)
            throw new Error("The parameter 'propertyNearestId' cannot be null.");
        else if (propertyNearestId !== undefined)
            url_ += "propertyNearestId=" + encodeURIComponent("" + propertyNearestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiPropertynearestDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiPropertynearestDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiPropertynearestDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiSellerGetbyid(userId: string): Observable<ProfileInformationModel> {
        let url_ = this.baseUrl + "/api/seller/getbyid/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSellerGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSellerGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileInformationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileInformationModel>;
        }));
    }

    protected processApiSellerGetbyid(response: HttpResponseBase): Observable<ProfileInformationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProfileInformationModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileInformationModel>(null as any);
    }

    apiSellerUpdate(profileId: string | undefined, model: UpdateProfileInformationModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/seller/update?";
        if (profileId === null)
            throw new Error("The parameter 'profileId' cannot be null.");
        else if (profileId !== undefined)
            url_ += "profileId=" + encodeURIComponent("" + profileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSellerUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSellerUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiSellerUpdate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiSellerGetpaging(pagingModel: PagingSellerModel): Observable<PaginatedListOfProfileInformationModel> {
        let url_ = this.baseUrl + "/api/seller/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSellerGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSellerGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProfileInformationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProfileInformationModel>;
        }));
    }

    protected processApiSellerGetpaging(response: HttpResponseBase): Observable<PaginatedListOfProfileInformationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfProfileInformationModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfProfileInformationModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfProfileInformationModel>(null as any);
    }

    apiSocialnetworkCreate(model: CreateSocialNetworkModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/socialnetwork/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSocialnetworkCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSocialnetworkCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiSocialnetworkCreate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiSocialnetworkGetbyid(id: string): Observable<SocialNetworkModel> {
        let url_ = this.baseUrl + "/api/socialnetwork/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSocialnetworkGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSocialnetworkGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SocialNetworkModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SocialNetworkModel>;
        }));
    }

    protected processApiSocialnetworkGetbyid(response: HttpResponseBase): Observable<SocialNetworkModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SocialNetworkModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SocialNetworkModel>(null as any);
    }

    apiSocialnetworkDelete(socialNetworkId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/socialnetwork/delete?";
        if (socialNetworkId === null)
            throw new Error("The parameter 'socialNetworkId' cannot be null.");
        else if (socialNetworkId !== undefined)
            url_ += "socialNetworkId=" + encodeURIComponent("" + socialNetworkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSocialnetworkDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSocialnetworkDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiSocialnetworkDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiSocialnetworkUpdate(socialNetworkId: string | undefined, model: CreateSocialNetworkModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/socialnetwork/update?";
        if (socialNetworkId === null)
            throw new Error("The parameter 'socialNetworkId' cannot be null.");
        else if (socialNetworkId !== undefined)
            url_ += "socialNetworkId=" + encodeURIComponent("" + socialNetworkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSocialnetworkUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSocialnetworkUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiSocialnetworkUpdate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiSocialnetworkGetpaging(pagingModel: PagingSocialNetworkModel): Observable<PaginatedListOfSocialNetworkModel> {
        let url_ = this.baseUrl + "/api/socialnetwork/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSocialnetworkGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSocialnetworkGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfSocialNetworkModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfSocialNetworkModel>;
        }));
    }

    protected processApiSocialnetworkGetpaging(response: HttpResponseBase): Observable<PaginatedListOfSocialNetworkModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfSocialNetworkModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfSocialNetworkModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfSocialNetworkModel>(null as any);
    }

    apiSupplierGetbyid(userId: string): Observable<ProfileInformationModel> {
        let url_ = this.baseUrl + "/api/supplier/getbyid/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSupplierGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSupplierGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileInformationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileInformationModel>;
        }));
    }

    protected processApiSupplierGetbyid(response: HttpResponseBase): Observable<ProfileInformationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProfileInformationModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfileInformationModel>(null as any);
    }

    apiSupplierUpdate(profileId: string | undefined, model: UpdateProfileInformationModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/supplier/update?";
        if (profileId === null)
            throw new Error("The parameter 'profileId' cannot be null.");
        else if (profileId !== undefined)
            url_ += "profileId=" + encodeURIComponent("" + profileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSupplierUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSupplierUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiSupplierUpdate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiSupplierGetpaging(pagingModel: PagingSupplierModel): Observable<PaginatedListOfProfileInformationModel> {
        let url_ = this.baseUrl + "/api/supplier/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiSupplierGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiSupplierGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProfileInformationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProfileInformationModel>;
        }));
    }

    protected processApiSupplierGetpaging(response: HttpResponseBase): Observable<PaginatedListOfProfileInformationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfProfileInformationModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfProfileInformationModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfProfileInformationModel>(null as any);
    }

    apiTimeforpostCreate(model: CreateTimeForPostModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/timeforpost/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTimeforpostCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTimeforpostCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiTimeforpostCreate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiTimeforpostGetbyid(id: string): Observable<TimeForPostModel> {
        let url_ = this.baseUrl + "/api/timeforpost/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTimeforpostGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTimeforpostGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimeForPostModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimeForPostModel>;
        }));
    }

    protected processApiTimeforpostGetbyid(response: HttpResponseBase): Observable<TimeForPostModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimeForPostModel;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ValidationProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TimeForPostModel>(null as any);
    }

    apiTimeforpostGetall(): Observable<TimeForPostModel[]> {
        let url_ = this.baseUrl + "/api/timeforpost/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTimeforpostGetall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTimeforpostGetall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimeForPostModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimeForPostModel[]>;
        }));
    }

    protected processApiTimeforpostGetall(response: HttpResponseBase): Observable<TimeForPostModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TimeForPostModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TimeForPostModel[]>(null as any);
    }

    apiTimeforpostDelete(timeForPostId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/timeforpost/delete?";
        if (timeForPostId === null)
            throw new Error("The parameter 'timeForPostId' cannot be null.");
        else if (timeForPostId !== undefined)
            url_ += "timeForPostId=" + encodeURIComponent("" + timeForPostId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTimeforpostDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTimeforpostDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiTimeforpostDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiTimeforpostUpdate(timeForPostId: string | undefined, model: CreateTimeForPostModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/timeforpost/update?";
        if (timeForPostId === null)
            throw new Error("The parameter 'timeForPostId' cannot be null.");
        else if (timeForPostId !== undefined)
            url_ += "timeForPostId=" + encodeURIComponent("" + timeForPostId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTimeforpostUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTimeforpostUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiTimeforpostUpdate(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiTimeforpostGetpaging(pagingModel: PagingTimeForPostModel): Observable<PaginatedListOfTimeForPostModel> {
        let url_ = this.baseUrl + "/api/timeforpost/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiTimeforpostGetpaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiTimeforpostGetpaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfTimeForPostModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfTimeForPostModel>;
        }));
    }

    protected processApiTimeforpostGetpaging(response: HttpResponseBase): Observable<PaginatedListOfTimeForPostModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfTimeForPostModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfTimeForPostModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfTimeForPostModel>(null as any);
    }

    apiUserLogin(request: LoginUserModel): Observable<IdentityResult> {
        let url_ = this.baseUrl + "/api/user/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityResult>;
        }));
    }

    protected processApiUserLogin(response: HttpResponseBase): Observable<IdentityResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdentityResult;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdentityResult;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdentityResult>(null as any);
    }

    apiUserLogout(): Observable<void> {
        let url_ = this.baseUrl + "/api/user/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processApiUserLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    apiUserRefreshToken(request: RefreshTokenModel): Observable<IdentityResult> {
        let url_ = this.baseUrl + "/api/user/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityResult>;
        }));
    }

    protected processApiUserRefreshToken(response: HttpResponseBase): Observable<IdentityResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdentityResult;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdentityResult>(null as any);
    }

    apiUserInfo(): Observable<IdentityResult> {
        let url_ = this.baseUrl + "/api/user/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityResult>;
        }));
    }

    protected processApiUserInfo(response: HttpResponseBase): Observable<IdentityResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdentityResult;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdentityResult>(null as any);
    }

    apiUserVerifyaccount(request: VerifyAccountModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/user/verifyaccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserVerifyaccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserVerifyaccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiUserVerifyaccount(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiUserForgetPassword(request: ForgetPasswordModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/user/forget-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserForgetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserForgetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiUserForgetPassword(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiUserResetPassword(request: ResetPasswordModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/user/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiUserResetPassword(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiUserRegister(request: RegisterModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/user/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiUserRegister(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiUserDelete(userId: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/user/delete?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUserDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUserDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiUserDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            result204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result204);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiUsersavedsearchCreatesavedsearch(model: CreateUserSavedSearchModel): Observable<Result> {
        let url_ = this.baseUrl + "/api/usersavedsearch/createsavedsearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUsersavedsearchCreatesavedsearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUsersavedsearchCreatesavedsearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiUsersavedsearchCreatesavedsearch(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateUserSavedSearchModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiUsersavedsearchSorting(sortingUserSavedSearchModel: SortingUserSavedSearchModel): Observable<PaginatedListOfUserSavedSearchModel> {
        let url_ = this.baseUrl + "/api/usersavedsearch/sorting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sortingUserSavedSearchModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUsersavedsearchSorting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUsersavedsearchSorting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfUserSavedSearchModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfUserSavedSearchModel>;
        }));
    }

    protected processApiUsersavedsearchSorting(response: HttpResponseBase): Observable<PaginatedListOfUserSavedSearchModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SortingUserSavedSearchModel;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaginatedListOfUserSavedSearchModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfUserSavedSearchModel>(null as any);
    }

    apiUsersavedsearchDelete(id: string | undefined): Observable<Result> {
        let url_ = this.baseUrl + "/api/usersavedsearch/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUsersavedsearchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUsersavedsearchDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiUsersavedsearchDelete(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }

    apiUsersavedsearchDeleteall(): Observable<Result> {
        let url_ = this.baseUrl + "/api/usersavedsearch/deleteall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApiUsersavedsearchDeleteall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiUsersavedsearchDeleteall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Result>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Result>;
        }));
    }

    protected processApiUsersavedsearchDeleteall(response: HttpResponseBase): Observable<Result> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Result;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Result>(null as any);
    }
}

export interface UserResult {
    id?: string | undefined;
    email?: string | undefined;
    userName?: string | undefined;
    lockoutEnabled?: boolean;
    emailConfirmed?: boolean;
    roleName?: string | undefined;
    personalInformation?: ProfileInformationModel | undefined;
}

export interface AuditableModel {
    createTime?: Date;
    createBy?: string | undefined;
    updateTime?: Date | undefined;
    updateBy?: string | undefined;
    isDeleted?: DeletedStatus;
    currentState?: number;
}

export interface ProfileInformationModel extends AuditableModel {
    id?: string;
    userId?: string;
    avatar?: string | undefined;
    avatarUrl?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    address?: string | undefined;
    descriptions?: string | undefined;
    birthDay?: Date;
    genderType?: GenderType;
    status?: ActiveStatus;
    roleName?: string | undefined;
    agency?: string | undefined;
    license?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    propertyCount?: number | undefined;
    socialNetworks?: SocialNetworkUserModel[] | undefined;
}

export enum GenderType {
    Male = 1,
    Female = 2,
    Other = 3,
}

export enum ActiveStatus {
    Active = 1,
    InActive = 2,
    All = 3,
}

export interface SocialNetworkUserModel extends AuditableModel {
    id?: string;
    socialNetworkId?: string;
    profileId?: string;
    socialNetworkName?: string | undefined;
    socialNetwokIcon?: string | undefined;
    socialNetworkIconUrl?: string | undefined;
}

export enum DeletedStatus {
    False = 1,
    True = 2,
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export interface UserModel {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    descriptions?: string | undefined;
    employee?: string | undefined;
    phoneNumber?: string | undefined;
    isDelete?: boolean;
    isVerify?: boolean;
    roleId?: string | undefined;
    role?: string | undefined;
}

export interface CreateUserResult {
    email?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
}

export interface CreateUserModel {
    email: string;
    userName: string;
    phoneNumber: string;
    roleDefinitionId?: string | undefined;
    lastName?: string | undefined;
    sirName?: string | undefined;
    fullName?: string | undefined;
    address?: string | undefined;
    avatar?: string | undefined;
    birthDay?: Date;
    status?: ActiveStatus;
    genderType?: GenderType;
    levelDefinitionId?: string | undefined;
    titleReferenceId?: string | undefined;
    distributorId?: string | undefined;
}

export interface Result {
    succeeded?: boolean;
    errors?: string[] | undefined;
    objectReturn?: any | undefined;
}

export interface CreateInternalUserModel {
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    departmentId?: string;
    notes?: string | undefined;
    accountGroupId?: string;
    gender?: GenderType | undefined;
}

export interface ResetPasswordResult {
    email?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
}

export interface LockUserModel {
    userId: string;
}

export interface RoleModel {
    id?: string | undefined;
    name?: string | undefined;
}

export interface AttachmentTypeModel {
    id?: string;
    name?: string | undefined;
    created?: Date;
    lastModified?: Date;
}

export interface CreateBannerModel {
    bannerName?: string | undefined;
    bannerType?: BannerTypes | undefined;
    imageUrl?: string | undefined;
    imagePathUrl?: string | undefined;
    descriptions?: string | undefined;
    bannerOrder?: number | undefined;
}

export enum BannerTypes {
    HomePage = 1,
    ProjectPage = 2,
}

export interface BannerModel {
    id?: string;
    bannerName?: string | undefined;
    bannerType?: BannerTypes | undefined;
    imageUrl?: string | undefined;
    imagePathUrl?: string | undefined;
    descriptions?: string | undefined;
    bannerOrder?: number | undefined;
    bannerTypeName?: string | undefined;
    createTime?: Date;
}

export interface ValidationProblemDetails extends ProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;
}

export interface PaginatedListOfBannerModel {
    items?: BannerModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface PagingIndexModel {
    pageNumber?: number | undefined;
    pageSize?: number | undefined;
}

export interface PagingBannerModel extends PagingIndexModel {
}

export interface CreateConfigModel {
    receiveEmailContactUs?: string | undefined;
    receiveEmailBookShowing?: string | undefined;
    host?: string | undefined;
    port?: number;
    userName?: string | undefined;
    password?: string | undefined;
    displayName?: string | undefined;
}

export interface ConfigModel extends AuditableModel {
    id?: string;
    receiveEmailContactUs?: string | undefined;
    receiveEmailBookShowing?: string | undefined;
    host?: string | undefined;
    port?: number;
    userName?: string | undefined;
    password?: string | undefined;
    displayName?: string | undefined;
    listReceiveEmailContactUs?: string[] | undefined;
    listReceiveEmailBookShowing?: string[] | undefined;
}

export interface CreateContactModel {
    subject?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    message?: string | undefined;
    propertyId?: string | undefined;
    contactType?: ContactType;
}

export enum ContactType {
    Contact = 1,
    Question = 2,
    Email = 3,
    Book = 4,
}

export interface ContactModel extends AuditableModel {
    id?: string;
    subject?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    message?: string | undefined;
    contactType?: ContactType;
}

export interface PaginatedListOfContactModel {
    items?: ContactModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface PagingContactModel extends PagingIndexModel {
}

export interface ImageCategoryModel {
    id?: string;
    name?: string | undefined;
    created?: Date;
    lastModified?: Date;
}

export interface PropertyTypeModel {
    id?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
}

export interface CreateNewsCategoryModel {
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
}

export interface NewsCategoryModel extends AuditableModel {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isApprove?: NewsApproveStatus | undefined;
}

export enum NewsApproveStatus {
    New = 1,
    Active = 2,
    InActive = 3,
    Lock = 4,
}

export interface ListNewsCategoryModel extends AuditableModel {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isApprove?: NewsApproveStatus;
    isApproveName?: string | undefined;
    approveDate?: Date | undefined;
}

export interface PaginatedListOfListNewsCategoryModel {
    items?: ListNewsCategoryModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface PagingNewsCategoryModel extends PagingIndexModel {
}

export interface SearchingNewsCategoryModel extends PagingIndexModel {
    title?: string | undefined;
    isApprove?: NewsApproveStatus | undefined;
}

export interface CreateNewsModel {
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    keyword?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    categoryId?: string;
    imageUrl?: string | undefined;
    featured?: boolean | undefined;
    isHotNews?: boolean | undefined;
    isWellRead?: boolean | undefined;
    position?: number | undefined;
}

export interface NewsModel extends AuditableModel {
    id?: string;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    keyword?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    statusId?: number;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    categoryId?: string;
    imageUrl?: string | undefined;
    imagePathUrl?: string | undefined;
    categoryName?: string | undefined;
    featured?: boolean | undefined;
    isHotNews?: boolean | undefined;
    isWellRead?: boolean | undefined;
    viewCount?: number | undefined;
    isApprove?: NewsApproveStatus;
    approveDate?: Date | undefined;
    position?: number;
    category?: NewsCategoryModel | undefined;
}

export interface ListNewsModel extends AuditableModel {
    id?: string;
    imageUrl?: string | undefined;
    imagePathUrl?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    categoryId?: string;
    featured?: boolean | undefined;
    isHotNews?: boolean | undefined;
    isWellRead?: boolean | undefined;
    viewCount?: number | undefined;
    isApprove?: NewsApproveStatus;
    approveDate?: Date | undefined;
    isApproveName?: string | undefined;
    category?: NewsCategoryModel | undefined;
}

export interface PaginatedListOfListNewsModel {
    items?: ListNewsModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface PagingNewsModel extends PagingIndexModel {
}

export interface SearchingNewsModel extends PagingIndexModel {
    title?: string | undefined;
}

export interface SearchingNewsForAdminModel extends SearchingNewsModel {
    isApprove?: NewsApproveStatus | undefined;
    categoryId?: string | undefined;
    isHotNew?: boolean | undefined;
}

export interface ListNewsGroupByCategoryModel extends AuditableModel {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    news?: ListNewsModel[] | undefined;
}

export interface PaginatedListOfNewsModel {
    items?: NewsModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface PaginatedListOfNotificationModel {
    items?: NotificationModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface NotificationModel {
    id?: string;
    title?: string | undefined;
    titleVi?: string | undefined;
    content?: string | undefined;
    contentVi?: string | undefined;
    link?: string | undefined;
    isPosted?: boolean;
    postedTime?: Date | undefined;
    numberOfDaysAgo?: number;
    postedBy?: string | undefined;
}

export interface CreateNotificationModel {
    title?: string | undefined;
    titleVi?: string | undefined;
    content?: string | undefined;
    contentVi?: string | undefined;
    link?: string | undefined;
    isPosted?: boolean;
}

export interface SortingNotificationModel {
    pageNumber?: number;
    pageSize?: number;
    newest?: boolean | undefined;
    oldest?: boolean | undefined;
    nameOrder?: boolean | undefined;
    nameOrderDescending?: boolean | undefined;
}

export interface FilterNotificationModel {
    pageNumber?: number;
    pageSize?: number;
    keyword?: string | undefined;
    isPosted?: boolean | undefined;
}

export interface UpdateNotificationModel {
    title?: string | undefined;
    titleVi?: string | undefined;
    content?: string | undefined;
    contentVi?: string | undefined;
    link?: string | undefined;
}

export interface PaginatedListOfNotificationUserModel {
    items?: NotificationUserModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface NotificationUserModel {
    id?: string;
    title?: string | undefined;
    titleVi?: string | undefined;
    content?: string | undefined;
    contentVi?: string | undefined;
    link?: string | undefined;
    isPosted?: boolean;
    postedTime?: Date | undefined;
    numberOfDaysAgo?: number;
    postedBy?: string | undefined;
    isSeen?: boolean;
}

export interface AttachmentModel {
    id?: string;
    groupId?: string;
    fileName?: string | undefined;
    fileType?: string | undefined;
    filePath?: string | undefined;
    fileUrl?: string | undefined;
    fileSize?: number | undefined;
    created?: Date;
    attachmentTypeId?: string;
    attachmentType?: AttachmentTypeModel | undefined;
    serviceTypeId?: string;
    referenceId?: string | undefined;
    attachmentTypeName?: string | undefined;
}

export interface AttachmentCollectionFilterModel {
    attachmentType?: string | undefined;
    serviceType?: string | undefined;
    referenceIds?: (string | undefined)[] | undefined;
}

export interface UploadMultipleFileRequestModel {
    files?: string[] | undefined;
    attachmentType?: string | undefined;
    referenceId?: string | undefined;
    imageCategory?: string | undefined;
}

export interface ChangePasswordModel {
    userName: string;
    oldPassword: string;
    newPassword: string;
    confirmPassword?: string | undefined;
}

export interface UpdateProfileModel {
    avatarFilePath?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    address?: string | undefined;
}

export interface ForgetPasswordModel {
    email: string;
}

export interface CreateProjectModel {
    propertyTypeId?: string | undefined;
    projectVi?: string | undefined;
    projectEn?: string | undefined;
    coverImage?: string | undefined;
    projectLogo?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    developer?: string | undefined;
    video?: string | undefined;
    virtualTour?: string | undefined;
    floorPlans?: string | undefined;
    mapViewImage?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    street?: string | undefined;
    descriptions?: string | undefined;
    longtitude?: string | undefined;
    latitude?: string | undefined;
    projectFeatures?: CreateProjectFeatureModel[] | undefined;
    projectImages?: CreateProjectImageModel[] | undefined;
    projectSellers?: CreateProjectSellerModel[] | undefined;
}

export interface CreateProjectFeatureModel {
    projectFeatureId?: string | undefined;
}

export interface CreateProjectImageModel {
    name?: string | undefined;
    imagesPath?: string | undefined;
}

export interface CreateProjectSellerModel {
    userId?: string;
}

export interface ProjectModel extends AuditableModel {
    id?: string;
    propertyTypeId?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
    projectVi?: string | undefined;
    projectEn?: string | undefined;
    coverImage?: string | undefined;
    coverImageUrl?: string | undefined;
    projectLogo?: string | undefined;
    projectLogoUrl?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    developer?: string | undefined;
    video?: string | undefined;
    virtualTour?: string | undefined;
    floorPlans?: string | undefined;
    mapViewImage?: string | undefined;
    mapViewImageUrl?: string | undefined;
    status?: ProjectStatus;
    statusName?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    provinceName?: string | undefined;
    districtName?: string | undefined;
    wardName?: string | undefined;
    street?: string | undefined;
    descriptions?: string | undefined;
    longtitude?: string | undefined;
    latitude?: string | undefined;
    viewCount?: number | undefined;
    isApprove?: ProjectApproveStatus;
    approveStatusName?: string | undefined;
    approveDate?: Date | undefined;
    projectFeatures?: ProjectFeatureModel[] | undefined;
    projectImages?: ProjectImageModel[] | undefined;
    projectSellers?: ProjectSellerModel[] | undefined;
}

export enum ProjectStatus {
    OpenForSale = 1,
    CommingSoon = 2,
    AlmostSoldOut = 3,
}

export enum ProjectApproveStatus {
    New = 1,
    Active = 2,
    InActive = 3,
    Lock = -1,
}

export interface ProjectFeatureModel extends AuditableModel {
    id?: string;
    projectId?: string;
    projectFeatureId?: string | undefined;
    projectFeatureVi?: string | undefined;
    projectFeatureEn?: string | undefined;
    descriptions?: string | undefined;
}

export interface ProjectImageModel extends AuditableModel {
    id?: string;
    name?: string | undefined;
    imagesPath?: string | undefined;
    imagesPathUrl?: string | undefined;
    projectId?: string;
}

export interface ProjectSellerModel extends AuditableModel {
    id?: string;
    projectId?: string;
    userId?: string;
    avatar?: string | undefined;
    avatarUrl?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    agency?: string | undefined;
    propertyCount?: number | undefined;
    socialNetworkUsers?: SocialNetworkUserModel[] | undefined;
}

export interface UpdateProjectModel extends CreateProjectModel {
    status?: ProjectStatus;
}

export interface PaginatedListOfProjectModel {
    items?: ProjectModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface PagingProjectModel extends PagingIndexModel {
}

export interface SearchProjectModel extends PagingIndexModel {
    projectName?: string | undefined;
    status?: ProjectStatus | undefined;
    location?: string | undefined;
    propertyTypeId?: string | undefined;
    sortingModel?: SortingProjectModel | undefined;
}

export interface SortingProjectModel {
    latest?: boolean | undefined;
    oldest?: boolean | undefined;
    mostView?: boolean | undefined;
    leastView?: boolean | undefined;
}

export interface AdministrativeByProjectModel {
    code?: string | undefined;
    name?: string | undefined;
    nameWithType?: string | undefined;
}

export interface SuggestSearchProjectModel {
    projectId?: string;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
}

export interface SearchProjectForAdminModel extends PagingIndexModel {
    projectName?: string | undefined;
    isApprove?: ProjectApproveStatus | undefined;
    status?: ProjectStatus | undefined;
    propertyTypeId?: string | undefined;
    sortingModel?: SortingProjectModel | undefined;
}

export interface CreatePropertyModel {
    transactionTypeId?: string | undefined;
    propertyTypeId?: string | undefined;
    coverImage?: string | undefined;
    videoLink?: string | undefined;
    virtualVideoLink?: string | undefined;
    address?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    street?: string | undefined;
    projectId?: string;
    propertyAddressVi?: string | undefined;
    propertyAddressEn?: string | undefined;
    title?: string | undefined;
    descriptions?: string | undefined;
    supplierId?: string;
    lotSize?: number | undefined;
    price?: number | undefined;
    currencyId?: string | undefined;
    bedroomId?: string | undefined;
    bathroomId?: string | undefined;
    floorsNumber?: number | undefined;
    totalBuildingFloors?: number | undefined;
    yearCompleted?: Date | undefined;
    longitude?: string | undefined;
    latitude?: string | undefined;
    propertyImages?: CreatePropertyImageModel[] | undefined;
    propertyViews?: CreatePropertyViewModel[] | undefined;
    propertyAmenitiesNearbys?: CreatePropertyAmenitiesNearbyModel[] | undefined;
}

export interface CreatePropertyImageModel {
    name?: string | undefined;
    imagesPath?: string | undefined;
    notes?: string | undefined;
}

export interface CreatePropertyViewModel {
    viewId?: string | undefined;
}

export interface CreatePropertyAmenitiesNearbyModel {
    amenitiesNearbyId?: string | undefined;
}

export interface ListPropertyModel extends AuditableModel {
    id?: string;
    title?: string | undefined;
    propertyNumber?: string | undefined;
    coverImage?: string | undefined;
    coverImageUrl?: string | undefined;
    propertyAddressVi?: string | undefined;
    propertyAddressEn?: string | undefined;
    price?: number | undefined;
    currencyId?: string | undefined;
    currencyName?: string | undefined;
    currencyNotation?: string | undefined;
    transactionTypeId?: string | undefined;
    transactionTypeVi?: string | undefined;
    transactionTypeEn?: string | undefined;
    bedroomId?: string | undefined;
    bedroomVi?: string | undefined;
    bedroomEn?: string | undefined;
    bathroomId?: string | undefined;
    bathroomVi?: string | undefined;
    bathroomEn?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    provinceName?: string | undefined;
    districtName?: string | undefined;
    wardName?: string | undefined;
    coordinatesProvince?: string | undefined;
    coordinatesDistrict?: string | undefined;
    coordinatesWard?: string | undefined;
    location?: string | undefined;
    lotSize?: number | undefined;
    longitude?: string | undefined;
    latitude?: string | undefined;
    isApprove?: PropertyApproveStatus;
    approveStatusName?: string | undefined;
    timeForPostId?: string | undefined;
    timeForPostValue?: number | undefined;
    timeForPostName?: string | undefined;
    timeRemain?: number | undefined;
    approveDate?: Date | undefined;
    expiredDate?: Date | undefined;
    isTemp?: boolean;
    viewCount?: number;
}

export enum PropertyApproveStatus {
    New = 1,
    Active = 2,
    InActive = 3,
    Expired = 4,
    Draft = 5,
    Lock = -1,
}

export interface FilterPropertyByUserModel {
    transactionTypeId?: string | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    listStatus?: PropertyApproveStatus[] | undefined;
}

export interface BasicPropertyModel {
    id?: string;
    longitude?: string | undefined;
    latitude?: string | undefined;
}

export interface PropertyModel extends AuditableModel {
    id?: string;
    propertyNumber?: string | undefined;
    transactionTypeId?: string | undefined;
    transactionTypeVi?: string | undefined;
    transactionTypeEn?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
    coverImage?: string | undefined;
    coverImageUrl?: string | undefined;
    videoLink?: string | undefined;
    virtualVideoLink?: string | undefined;
    address?: string | undefined;
    provinceCode?: string | undefined;
    provinceName?: string | undefined;
    districtCode?: string | undefined;
    districtName?: string | undefined;
    wardCode?: string | undefined;
    wardName?: string | undefined;
    street?: string | undefined;
    projectId?: string;
    projectVi?: string | undefined;
    projectEn?: string | undefined;
    propertyAddressVi?: string | undefined;
    propertyAddressEn?: string | undefined;
    title?: string | undefined;
    descriptions?: string | undefined;
    lotSize?: number | undefined;
    price?: number | undefined;
    currencyId?: string | undefined;
    currencyName?: string | undefined;
    currencyNotation?: string | undefined;
    bedroomId?: string | undefined;
    bedroomVi?: string | undefined;
    bedroomEn?: string | undefined;
    bathroomId?: string | undefined;
    bathroomVi?: string | undefined;
    bathroomEn?: string | undefined;
    floorsNumber?: number | undefined;
    totalBuildingFloors?: number | undefined;
    yearCompleted?: Date | undefined;
    longitude?: string | undefined;
    latitude?: string | undefined;
    timeForPostId?: string | undefined;
    timeForPostValue?: number | undefined;
    timeForPostName?: string | undefined;
    timeRemain?: number | undefined;
    isApprove?: PropertyApproveStatus;
    approveStatusName?: string | undefined;
    approveDate?: Date | undefined;
    isTemp?: boolean;
    viewCount?: number;
    supplierId?: string;
    supplierAvatar?: string | undefined;
    supplierFirstName?: string | undefined;
    supplierLastName?: string | undefined;
    supplierEmail?: string | undefined;
    suppierPhoneNumber1?: string | undefined;
    suppierPhoneNumber2?: string | undefined;
    propertyImages?: PropertyImageModel[] | undefined;
    propertyViews?: PropertyViewModel[] | undefined;
    propertyAmenitiesNearbys?: PropertyAmenitiesNearbyModel[] | undefined;
    propertySellers?: PropertySellerModel[] | undefined;
}

export interface PropertyImageModel {
    id?: string;
    name?: string | undefined;
    imagesPath?: string | undefined;
    propertyId?: string;
    notes?: string | undefined;
    imagesUrl?: string | undefined;
}

export interface PropertyViewModel extends AuditableModel {
    id?: string;
    propertyId?: string;
    viewId?: string | undefined;
    viewVi?: string | undefined;
    viewEn?: string | undefined;
    viewDescriptions?: string | undefined;
}

export interface PropertyAmenitiesNearbyModel extends AuditableModel {
    id?: string;
    propertyId?: string;
    amenitiesNearbyId?: string | undefined;
    amenitiesNearbyVi?: string | undefined;
    amenitiesNearbyEn?: string | undefined;
    descriptions?: string | undefined;
}

export interface PropertySellerModel extends AuditableModel {
    id?: string;
    propertyId?: string;
    userId?: string;
    avatar?: string | undefined;
    avatarUrl?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    email?: string | undefined;
    agency?: string | undefined;
    propertyCount?: number | undefined;
    socialNetworkUsers?: SocialNetworkUserModel[] | undefined;
}

export interface UpdatePropertyModel extends CreatePropertyModel {
    propertySellers?: CreatePropertySellerModel[] | undefined;
    propertyMeetingNote?: CreatePropertyMeetingNoteModel | undefined;
}

export interface CreatePropertySellerModel {
    userId?: string;
}

export interface CreatePropertyMeetingNoteModel {
    meetingNoteTitle?: string | undefined;
    meetingNoteContent?: string | undefined;
}

export interface ApprovePropertyModel {
    propertyId?: string;
    timeForPostId?: string;
}

export interface PaginatedListOfListPropertyModel {
    items?: ListPropertyModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface SearchingPropertyModel extends PagingIndexModel {
    propertyKeyWord?: string | undefined;
    propertyTypeId?: string | undefined;
    transactionTypeId?: string | undefined;
    administrativeCode?: string | undefined;
    minPrice?: number | undefined;
    maxPrice?: number | undefined;
    bedroomId?: string | undefined;
    bathroomId?: string | undefined;
    landSize?: number | undefined;
    listedSince?: Date | undefined;
    sortingModel?: SortingPropertyModel | undefined;
}

export interface SortingPropertyModel {
    newest?: boolean | undefined;
    oldest?: boolean | undefined;
    lowestPrice?: boolean | undefined;
    highestPrice?: boolean | undefined;
}

export interface SearchingPropertyForAdminModel extends PagingIndexModel {
    propertyNumber?: string | undefined;
    propertyTypeId?: string | undefined;
    transactionTypeId?: string | undefined;
    isApprove?: PropertyApproveStatus | undefined;
    sortingModel?: SortingPropertyModel | undefined;
}

export interface SuggestSearchPropertyModel {
    suggestAdministrative?: SuggestPropertyAdministrativeModel[] | undefined;
    suggestProperty?: SuggestPropertyModel[] | undefined;
}

export interface SuggestPropertyAdministrativeModel {
    administrativeCode?: string | undefined;
    administrativeName?: string | undefined;
}

export interface SuggestPropertyModel {
    propertyId?: string;
    propertyNumber?: string | undefined;
    address?: string | undefined;
}

export interface PagingNearestPropertyModel extends PagingIndexModel {
    ids?: string[] | undefined;
}

export interface PagingPropertyModel extends PagingIndexModel {
}

export interface CreatePropertyFavoriteModel {
    userId?: string;
    propertyId?: string;
}

export interface PagingPropertyFavoriteModel extends PagingIndexModel {
    userId?: string;
}

export interface CreatePropertyHeartModel {
    userId?: string;
    propertyId?: string;
}

export interface PagingPropertyHeartModel extends PagingIndexModel {
    userId?: string;
    sortingModel?: SortingFavouriteModel | undefined;
}

export interface SortingFavouriteModel {
    newest?: boolean | undefined;
    oldest?: boolean | undefined;
    lowestPrice?: boolean | undefined;
    highestPrice?: boolean | undefined;
    oldFavourite?: boolean | undefined;
    newFavourite?: boolean | undefined;
}

export interface PaginatedListOfListPropertyHeartModel {
    items?: ListPropertyHeartModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface ListPropertyHeartModel {
    userId?: string;
    propertyId?: string;
    title?: string | undefined;
    propertyNumber?: string | undefined;
    coverImage?: string | undefined;
    coverImageUrl?: string | undefined;
    propertyAddressVi?: string | undefined;
    propertyAddressEn?: string | undefined;
    price?: number | undefined;
    currencyId?: string | undefined;
    currencyName?: string | undefined;
    currencyNotation?: string | undefined;
    transactionTypeId?: string | undefined;
    transactionTypeVi?: string | undefined;
    transactionTypeEn?: string | undefined;
    bedroomId?: string | undefined;
    bedroomVi?: string | undefined;
    bedroomEn?: string | undefined;
    bathroomId?: string | undefined;
    bathroomVi?: string | undefined;
    bathroomEn?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    provinceName?: string | undefined;
    districtName?: string | undefined;
    wardName?: string | undefined;
    coordinatesProvince?: string | undefined;
    coordinatesDistrict?: string | undefined;
    coordinatesWard?: string | undefined;
    location?: string | undefined;
    lotSize?: number | undefined;
    longitude?: string | undefined;
    latitude?: string | undefined;
    isApprove?: PropertyApproveStatus;
    approveStatusName?: string | undefined;
    approveDate?: Date | undefined;
    createTime?: Date;
}

export interface PropertyMeetingNoteModel extends AuditableModel {
    id?: string;
    meetingNoteTitle?: string | undefined;
    meetingNoteContent?: string | undefined;
    propertyId?: string;
}

export interface CreatePropertyNearestModel {
    userId?: string;
    propertyId?: string;
}

export interface PagingPropertyNearestModel extends PagingIndexModel {
    userId?: string;
}

export interface UpdateProfileInformationModel {
    userId?: string;
    avatar?: string | undefined;
    avatarUrl?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    address?: string | undefined;
    descriptions?: string | undefined;
    birthDay?: Date;
    genderType?: GenderType;
    agency?: string | undefined;
    license?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    socialNetworks?: CreateSocialNetworkUserModel[] | undefined;
}

export interface CreateSocialNetworkUserModel {
    socialNetworkId?: string;
}

export interface PaginatedListOfProfileInformationModel {
    items?: ProfileInformationModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface PagingSellerModel extends PagingIndexModel {
}

export interface CreateSocialNetworkModel {
    appName?: string | undefined;
    iCon?: string | undefined;
    descriptions?: string | undefined;
}

export interface SocialNetworkModel extends AuditableModel {
    id?: string;
    appName?: string | undefined;
    iCon?: string | undefined;
    descriptions?: string | undefined;
    iConUrl?: string | undefined;
}

export interface PaginatedListOfSocialNetworkModel {
    items?: SocialNetworkModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface PagingSocialNetworkModel extends PagingIndexModel {
}

export interface PagingSupplierModel extends PagingIndexModel {
}

export interface CreateTimeForPostModel {
    value?: number | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
}

export interface TimeForPostModel extends AuditableModel {
    id?: string;
    value?: number | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
}

export interface PaginatedListOfTimeForPostModel {
    items?: TimeForPostModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface PagingTimeForPostModel extends PagingIndexModel {
}

export interface IdentityResult {
    userName?: string | undefined;
    roles?: string[] | undefined;
    email?: string | undefined;
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    succeeded?: boolean;
    errorMessage?: string | undefined;
    userStatus?: UserStatus;
}

export enum UserStatus {
    LoginFailed = 0,
    LoginSucceeded = 1,
    LockedUser = 2,
    MustChangePassword = 3,
}

export interface LoginUserModel {
    email: string;
    password: string;
    rememberMe?: boolean;
}

export interface RefreshTokenModel {
    refreshToken: string;
    userName: string;
}

export interface VerifyAccountModel {
    email: string;
    token: string;
}

export interface ResetPasswordModel {
    email: string;
    token: string;
    newPassword: string;
}

export interface RegisterModel {
    email: string;
    userName: string;
    password: string;
    avatar?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    descriptions?: string | undefined;
    genderType?: GenderType;
    role?: RoleTypes;
    socialNetworks?: CreateSocialNetworkUserModel[] | undefined;
}

export enum RoleTypes {
    SystemAdministrator = 1,
    InternalUser = 2,
    LocalService = 3,
    Seller = 4,
    Guest = 5,
    Supplier = 6,
}

export interface CreateUserSavedSearchModel {
    name?: string | undefined;
    keyword?: string | undefined;
    type?: string | undefined;
}

export interface SortingUserSavedSearchModel {
    pageNumber?: number;
    pageSize?: number;
    newest?: boolean | undefined;
    oldest?: boolean | undefined;
    nameOrder?: boolean | undefined;
    nameOrderDescending?: boolean | undefined;
}

export interface PaginatedListOfUserSavedSearchModel {
    items?: UserSavedSearchModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface UserSavedSearchModel {
    id?: string;
    userId?: string;
    name?: string | undefined;
    keyword?: string | undefined;
    type?: string | undefined;
    createTime?: Date;
    numberOfDaysAgo?: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}