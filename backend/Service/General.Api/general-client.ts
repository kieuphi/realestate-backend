//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { BaseClient } from './base-client';
import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class GeneralClient extends BaseClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : this.getBaseUrl("");

    }

    admin_CheckAdminCanAccess(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_CheckAdminCanAccess(_response));
        });
    }

    protected processAdmin_CheckAdminCanAccess(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    admin_RetriveAllUsers(  cancelToken?: CancelToken | undefined): Promise<UserResult[]> {
        let url_ = this.baseUrl + "/api/admin/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_RetriveAllUsers(_response));
        });
    }

    protected processAdmin_RetriveAllUsers(response: AxiosResponse): Promise<UserResult[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<UserResult[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResult[]>(null as any);
    }

    admin_CreateUser(createUsersRequest: CreateUserModel[] , cancelToken?: CancelToken | undefined): Promise<CreateUserResult[]> {
        let url_ = this.baseUrl + "/api/admin/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createUsersRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_CreateUser(_response));
        });
    }

    protected processAdmin_CreateUser(response: AxiosResponse): Promise<CreateUserResult[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CreateUserResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CreateUserResult[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(CreateUserResult.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateUserResult[]>(null as any);
    }

    admin_GetAllInternalAccount(  cancelToken?: CancelToken | undefined): Promise<UserModel[]> {
        let url_ = this.baseUrl + "/api/admin/getallinternalaccount";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_GetAllInternalAccount(_response));
        });
    }

    protected processAdmin_GetAllInternalAccount(response: AxiosResponse): Promise<UserModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<UserModel[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserModel[]>(null as any);
    }

    admin_GetUser(userId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<UserModel> {
        let url_ = this.baseUrl + "/api/admin/getbyuserid?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_GetUser(_response));
        });
    }

    protected processAdmin_GetUser(response: AxiosResponse): Promise<UserModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserModel.fromJS(resultData200);
            return Promise.resolve<UserModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = UserModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserModel>(null as any);
    }

    admin_CreateInternalUser(createUserProfile: CreateInternalUserModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/admin/createinternaluser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createUserProfile);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_CreateInternalUser(_response));
        });
    }

    protected processAdmin_CreateInternalUser(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    admin_ResendConfirmationAccountToken(userId: string , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/admin/resendconfirmationaccounttoken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_ResendConfirmationAccountToken(_response));
        });
    }

    protected processAdmin_ResendConfirmationAccountToken(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateInternalUserModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    admin_ResetPasswordUsers(userEmails: string[] , cancelToken?: CancelToken | undefined): Promise<ResetPasswordResult[]> {
        let url_ = this.baseUrl + "/api/admin/users/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userEmails);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_ResetPasswordUsers(_response));
        });
    }

    protected processAdmin_ResetPasswordUsers(response: AxiosResponse): Promise<ResetPasswordResult[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResetPasswordResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ResetPasswordResult[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(item);
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResetPasswordResult[]>(null as any);
    }

    admin_LockUsers(users: string[] , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/admin/users/lock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(users);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_LockUsers(_response));
        });
    }

    protected processAdmin_LockUsers(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(item);
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    admin_LockUser(request: LockUserModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/admin/user/lock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_LockUser(_response));
        });
    }

    protected processAdmin_LockUser(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    admin_UnlockUser(request: LockUserModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/admin/user/unlock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_UnlockUser(_response));
        });
    }

    protected processAdmin_UnlockUser(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    admin_UpdateInternalUser(user: UserModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/admin/updateinternaluser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_UpdateInternalUser(_response));
        });
    }

    protected processAdmin_UpdateInternalUser(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    admin_GetRoles(  cancelToken?: CancelToken | undefined): Promise<RoleModel[]> {
        let url_ = this.baseUrl + "/api/admin/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_GetRoles(_response));
        });
    }

    protected processAdmin_GetRoles(response: AxiosResponse): Promise<RoleModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RoleModel[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleModel[]>(null as any);
    }

    admin_VerifyUser(email: string | null , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/admin/user/verify/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAdmin_VerifyUser(_response));
        });
    }

    protected processAdmin_VerifyUser(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    attachmentType_GetAllAttachmentTypes(  cancelToken?: CancelToken | undefined): Promise<AttachmentTypeModel[]> {
        let url_ = this.baseUrl + "/api/attachmenttype";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachmentType_GetAllAttachmentTypes(_response));
        });
    }

    protected processAttachmentType_GetAllAttachmentTypes(response: AxiosResponse): Promise<AttachmentTypeModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AttachmentTypeModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttachmentTypeModel[]>(null as any);
    }

    attachmentType_GetAttachmentType(id: string , cancelToken?: CancelToken | undefined): Promise<AttachmentTypeModel> {
        let url_ = this.baseUrl + "/api/attachmenttype/detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processAttachmentType_GetAttachmentType(_response));
        });
    }

    protected processAttachmentType_GetAttachmentType(response: AxiosResponse): Promise<AttachmentTypeModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AttachmentTypeModel.fromJS(resultData200);
            return Promise.resolve<AttachmentTypeModel>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = AttachmentTypeModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttachmentTypeModel>(null as any);
    }

    banner_Create(model: CreateBannerModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/banner/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_Create(_response));
        });
    }

    protected processBanner_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    banner_GetById(id: string , cancelToken?: CancelToken | undefined): Promise<BannerModel> {
        let url_ = this.baseUrl + "/api/banner/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_GetById(_response));
        });
    }

    protected processBanner_GetById(response: AxiosResponse): Promise<BannerModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BannerModel.fromJS(resultData200);
            return Promise.resolve<BannerModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BannerModel>(null as any);
    }

    banner_GetAll(  cancelToken?: CancelToken | undefined): Promise<BannerModel[]> {
        let url_ = this.baseUrl + "/api/banner/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_GetAll(_response));
        });
    }

    protected processBanner_GetAll(response: AxiosResponse): Promise<BannerModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BannerModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BannerModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BannerModel[]>(null as any);
    }

    banner_Delete(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/banner/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_Delete(_response));
        });
    }

    protected processBanner_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    banner_PagingBanner(model: PagingBannerModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfBannerModel> {
        let url_ = this.baseUrl + "/api/banner/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_PagingBanner(_response));
        });
    }

    protected processBanner_PagingBanner(response: AxiosResponse): Promise<PaginatedListOfBannerModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfBannerModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfBannerModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfBannerModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfBannerModel>(null as any);
    }

    banner_Update(bannerId: string | undefined, model: CreateBannerModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/banner/update?";
        if (bannerId === null)
            throw new Error("The parameter 'bannerId' cannot be null.");
        else if (bannerId !== undefined)
            url_ += "bannerId=" + encodeURIComponent("" + bannerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_Update(_response));
        });
    }

    protected processBanner_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    banner_GetByType(type: BannerTypes | undefined , cancelToken?: CancelToken | undefined): Promise<BannerModel[]> {
        let url_ = this.baseUrl + "/api/banner/getbytype?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processBanner_GetByType(_response));
        });
    }

    protected processBanner_GetByType(response: AxiosResponse): Promise<BannerModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BannerModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BannerModel[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BannerModel[]>(null as any);
    }

    config_SaveConfig(model: CreateConfigModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/config/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processConfig_SaveConfig(_response));
        });
    }

    protected processConfig_SaveConfig(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    config_GetConfig(  cancelToken?: CancelToken | undefined): Promise<ConfigModel> {
        let url_ = this.baseUrl + "/api/config/getconfig";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processConfig_GetConfig(_response));
        });
    }

    protected processConfig_GetConfig(response: AxiosResponse): Promise<ConfigModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ConfigModel.fromJS(resultData200);
            return Promise.resolve<ConfigModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ConfigModel>(null as any);
    }

    contact_Create(model: CreateContactModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/contact/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContact_Create(_response));
        });
    }

    protected processContact_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    contact_GetById(id: string , cancelToken?: CancelToken | undefined): Promise<ContactModel> {
        let url_ = this.baseUrl + "/api/contact/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContact_GetById(_response));
        });
    }

    protected processContact_GetById(response: AxiosResponse): Promise<ContactModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContactModel.fromJS(resultData200);
            return Promise.resolve<ContactModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactModel>(null as any);
    }

    contact_GetAll(  cancelToken?: CancelToken | undefined): Promise<ContactModel[]> {
        let url_ = this.baseUrl + "/api/contact/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContact_GetAll(_response));
        });
    }

    protected processContact_GetAll(response: AxiosResponse): Promise<ContactModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ContactModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactModel[]>(null as any);
    }

    contact_Delete(contactId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/contact/delete?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContact_Delete(_response));
        });
    }

    protected processContact_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    contact_Update(contactId: string | undefined, model: CreateContactModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/contact/update?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContact_Update(_response));
        });
    }

    protected processContact_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    contact_PagingContact(pagingModel: PagingContactModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfContactModel> {
        let url_ = this.baseUrl + "/api/contact/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processContact_PagingContact(_response));
        });
    }

    protected processContact_PagingContact(response: AxiosResponse): Promise<PaginatedListOfContactModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfContactModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfContactModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfContactModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfContactModel>(null as any);
    }

    health_Health(  cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processHealth_Health(_response));
        });
    }

    protected processHealth_Health(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    imageCategory_GetAllImageCategory(  cancelToken?: CancelToken | undefined): Promise<ImageCategoryModel[]> {
        let url_ = this.baseUrl + "/api/imagecategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processImageCategory_GetAllImageCategory(_response));
        });
    }

    protected processImageCategory_GetAllImageCategory(response: AxiosResponse): Promise<ImageCategoryModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImageCategoryModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ImageCategoryModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ImageCategoryModel[]>(null as any);
    }

    map_GetProvincesData(  cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/map/getprovinces";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMap_GetProvincesData(_response));
        });
    }

    protected processMap_GetProvincesData(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    map_GetDistrictsData(  cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/map/getdistricts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMap_GetDistrictsData(_response));
        });
    }

    protected processMap_GetDistrictsData(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    map_GetWardsData(  cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/map/getwards";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMap_GetWardsData(_response));
        });
    }

    protected processMap_GetWardsData(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    map_FilterDisctrict(provinceCode: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/map/filterdisctrict?";
        if (provinceCode !== undefined && provinceCode !== null)
            url_ += "provinceCode=" + encodeURIComponent("" + provinceCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMap_FilterDisctrict(_response));
        });
    }

    protected processMap_FilterDisctrict(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    map_FilterWard(districtCode: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/map/filterward?";
        if (districtCode !== undefined && districtCode !== null)
            url_ += "districtCode=" + encodeURIComponent("" + districtCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMap_FilterWard(_response));
        });
    }

    protected processMap_FilterWard(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    map_GetCoordinateProvinceByCode(code: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/map/getcoordinateprovincebycode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMap_GetCoordinateProvinceByCode(_response));
        });
    }

    protected processMap_GetCoordinateProvinceByCode(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    map_GetCoordinateDistrictByCode(code: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/map/getcoordinatedistrictbycode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMap_GetCoordinateDistrictByCode(_response));
        });
    }

    protected processMap_GetCoordinateDistrictByCode(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    map_GetCoordinateWardByCode(code: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/map/getcoordinatewardbycode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMap_GetCoordinateWardByCode(_response));
        });
    }

    protected processMap_GetCoordinateWardByCode(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    map_GetCoordinateProvinceByName(nameWithType: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/map/getcoordinateprovincebyname?";
        if (nameWithType !== undefined && nameWithType !== null)
            url_ += "nameWithType=" + encodeURIComponent("" + nameWithType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMap_GetCoordinateProvinceByName(_response));
        });
    }

    protected processMap_GetCoordinateProvinceByName(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    map_GetCoordinateDistrictByName(nameWithType: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/map/getcoordinatedistrictbyname?";
        if (nameWithType !== undefined && nameWithType !== null)
            url_ += "nameWithType=" + encodeURIComponent("" + nameWithType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMap_GetCoordinateDistrictByName(_response));
        });
    }

    protected processMap_GetCoordinateDistrictByName(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    map_GetCoordinateWardByName(nameWithType: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/map/getcoordinatewardbyname?";
        if (nameWithType !== undefined && nameWithType !== null)
            url_ += "nameWithType=" + encodeURIComponent("" + nameWithType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMap_GetCoordinateWardByName(_response));
        });
    }

    protected processMap_GetCoordinateWardByName(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    masterData_GetMasterData(  cancelToken?: CancelToken | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/masterdata/getmasterdata";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetMasterData(_response));
        });
    }

    protected processMasterData_GetMasterData(response: AxiosResponse): Promise<any> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<any>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<any>(null as any);
    }

    masterData_GetPropertyTypeByTransaction(transactionId: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<PropertyTypeModel[]> {
        let url_ = this.baseUrl + "/api/masterdata/getpropertytypebytransaction?";
        if (transactionId !== undefined && transactionId !== null)
            url_ += "transactionId=" + encodeURIComponent("" + transactionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processMasterData_GetPropertyTypeByTransaction(_response));
        });
    }

    protected processMasterData_GetPropertyTypeByTransaction(response: AxiosResponse): Promise<PropertyTypeModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PropertyTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PropertyTypeModel[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyTypeModel[]>(null as any);
    }

    newsCategory_Create(model: CreateNewsCategoryModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newscategory/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_Create(_response));
        });
    }

    protected processNewsCategory_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newsCategory_GetById(id: string , cancelToken?: CancelToken | undefined): Promise<NewsCategoryModel> {
        let url_ = this.baseUrl + "/api/newscategory/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_GetById(_response));
        });
    }

    protected processNewsCategory_GetById(response: AxiosResponse): Promise<NewsCategoryModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsCategoryModel.fromJS(resultData200);
            return Promise.resolve<NewsCategoryModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsCategoryModel>(null as any);
    }

    newsCategory_GetAll(  cancelToken?: CancelToken | undefined): Promise<ListNewsCategoryModel[]> {
        let url_ = this.baseUrl + "/api/newscategory/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_GetAll(_response));
        });
    }

    protected processNewsCategory_GetAll(response: AxiosResponse): Promise<ListNewsCategoryModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListNewsCategoryModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ListNewsCategoryModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListNewsCategoryModel[]>(null as any);
    }

    newsCategory_Delete(newsCategoryId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newscategory/delete?";
        if (newsCategoryId === null)
            throw new Error("The parameter 'newsCategoryId' cannot be null.");
        else if (newsCategoryId !== undefined)
            url_ += "newsCategoryId=" + encodeURIComponent("" + newsCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_Delete(_response));
        });
    }

    protected processNewsCategory_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newsCategory_Update(newsCategoryId: string | undefined, model: CreateNewsCategoryModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newscategory/update?";
        if (newsCategoryId === null)
            throw new Error("The parameter 'newsCategoryId' cannot be null.");
        else if (newsCategoryId !== undefined)
            url_ += "newsCategoryId=" + encodeURIComponent("" + newsCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_Update(_response));
        });
    }

    protected processNewsCategory_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newsCategory_PagingNews(pagingModel: PagingNewsCategoryModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListNewsCategoryModel> {
        let url_ = this.baseUrl + "/api/newscategory/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_PagingNews(_response));
        });
    }

    protected processNewsCategory_PagingNews(response: AxiosResponse): Promise<PaginatedListOfListNewsCategoryModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListNewsCategoryModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListNewsCategoryModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListNewsCategoryModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListNewsCategoryModel>(null as any);
    }

    newsCategory_SearchingForAdmin(model: SearchingNewsCategoryModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListNewsCategoryModel> {
        let url_ = this.baseUrl + "/api/newscategory/searchingforadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_SearchingForAdmin(_response));
        });
    }

    protected processNewsCategory_SearchingForAdmin(response: AxiosResponse): Promise<PaginatedListOfListNewsCategoryModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListNewsCategoryModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListNewsCategoryModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListNewsCategoryModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListNewsCategoryModel>(null as any);
    }

    newsCategory_Post(newsCategoryId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newscategory/post?";
        if (newsCategoryId === null)
            throw new Error("The parameter 'newsCategoryId' cannot be null.");
        else if (newsCategoryId !== undefined)
            url_ += "newsCategoryId=" + encodeURIComponent("" + newsCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_Post(_response));
        });
    }

    protected processNewsCategory_Post(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newsCategory_UnPost(newsCategoryId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newscategory/unpost?";
        if (newsCategoryId === null)
            throw new Error("The parameter 'newsCategoryId' cannot be null.");
        else if (newsCategoryId !== undefined)
            url_ += "newsCategoryId=" + encodeURIComponent("" + newsCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_UnPost(_response));
        });
    }

    protected processNewsCategory_UnPost(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newsCategory_Active(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newscategory/active?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_Active(_response));
        });
    }

    protected processNewsCategory_Active(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newsCategory_InActive(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newscategory/inactive?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_InActive(_response));
        });
    }

    protected processNewsCategory_InActive(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newsCategory_Lock(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newscategory/lock?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_Lock(_response));
        });
    }

    protected processNewsCategory_Lock(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    newsCategory_UnLock(newsCategoryId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/newscategory/unlock?";
        if (newsCategoryId === null)
            throw new Error("The parameter 'newsCategoryId' cannot be null.");
        else if (newsCategoryId !== undefined)
            url_ += "newsCategoryId=" + encodeURIComponent("" + newsCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNewsCategory_UnLock(_response));
        });
    }

    protected processNewsCategory_UnLock(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_Create(model: CreateNewsModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_Create(_response));
        });
    }

    protected processNews_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_GetById(id: string , cancelToken?: CancelToken | undefined): Promise<NewsModel> {
        let url_ = this.baseUrl + "/api/news/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetById(_response));
        });
    }

    protected processNews_GetById(response: AxiosResponse): Promise<NewsModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NewsModel.fromJS(resultData200);
            return Promise.resolve<NewsModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NewsModel>(null as any);
    }

    news_GetAll(  cancelToken?: CancelToken | undefined): Promise<ListNewsModel[]> {
        let url_ = this.baseUrl + "/api/news/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetAll(_response));
        });
    }

    protected processNews_GetAll(response: AxiosResponse): Promise<ListNewsModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListNewsModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ListNewsModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListNewsModel[]>(null as any);
    }

    news_Delete(newsId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/delete?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_Delete(_response));
        });
    }

    protected processNews_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_Update(newsId: string | undefined, model: CreateNewsModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/update?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_Update(_response));
        });
    }

    protected processNews_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_PagingNews(pagingModel: PagingNewsModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListNewsModel> {
        let url_ = this.baseUrl + "/api/news/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_PagingNews(_response));
        });
    }

    protected processNews_PagingNews(response: AxiosResponse): Promise<PaginatedListOfListNewsModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListNewsModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListNewsModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListNewsModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListNewsModel>(null as any);
    }

    news_Searching(model: SearchingNewsModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListNewsModel> {
        let url_ = this.baseUrl + "/api/news/searching";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_Searching(_response));
        });
    }

    protected processNews_Searching(response: AxiosResponse): Promise<PaginatedListOfListNewsModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListNewsModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListNewsModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListNewsModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListNewsModel>(null as any);
    }

    news_SearchingForAdmin(model: SearchingNewsForAdminModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListNewsModel> {
        let url_ = this.baseUrl + "/api/news/searchingforadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_SearchingForAdmin(_response));
        });
    }

    protected processNews_SearchingForAdmin(response: AxiosResponse): Promise<PaginatedListOfListNewsModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListNewsModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListNewsModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListNewsModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListNewsModel>(null as any);
    }

    news_Post(newsId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/post?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_Post(_response));
        });
    }

    protected processNews_Post(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_UnPost(newsId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/unpost?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_UnPost(_response));
        });
    }

    protected processNews_UnPost(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_UnLock(newsId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/unlock?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_UnLock(_response));
        });
    }

    protected processNews_UnLock(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_GetHotNews(pagingModel: PagingNewsModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListNewsModel> {
        let url_ = this.baseUrl + "/api/news/gethotnews";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetHotNews(_response));
        });
    }

    protected processNews_GetHotNews(response: AxiosResponse): Promise<PaginatedListOfListNewsModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListNewsModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListNewsModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListNewsModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListNewsModel>(null as any);
    }

    news_GeWellReadNews(pagingModel: PagingNewsModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListNewsModel> {
        let url_ = this.baseUrl + "/api/news/gewellreadnews";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GeWellReadNews(_response));
        });
    }

    protected processNews_GeWellReadNews(response: AxiosResponse): Promise<PaginatedListOfListNewsModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListNewsModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListNewsModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListNewsModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListNewsModel>(null as any);
    }

    news_GetNewsGroupByCategory(  cancelToken?: CancelToken | undefined): Promise<ListNewsGroupByCategoryModel[]> {
        let url_ = this.baseUrl + "/api/news/getnewsgroupbycategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetNewsGroupByCategory(_response));
        });
    }

    protected processNews_GetNewsGroupByCategory(response: AxiosResponse): Promise<ListNewsGroupByCategoryModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ListNewsGroupByCategoryModel.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListNewsGroupByCategoryModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ListNewsGroupByCategoryModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListNewsGroupByCategoryModel[]>(null as any);
    }

    news_GetByCategoryId(categoryId: string, pagingModel: PagingNewsModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfNewsModel> {
        let url_ = this.baseUrl + "/api/news/getbycategoryid/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetByCategoryId(_response));
        });
    }

    protected processNews_GetByCategoryId(response: AxiosResponse): Promise<PaginatedListOfNewsModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfNewsModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfNewsModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfNewsModel>(null as any);
    }

    news_CountViewNews(newsId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/news/countviewnews?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_CountViewNews(_response));
        });
    }

    protected processNews_CountViewNews(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    news_GetNextNews(currentNewsId: string , cancelToken?: CancelToken | undefined): Promise<ListNewsModel> {
        let url_ = this.baseUrl + "/api/news/getnextnews/{currentNewsId}";
        if (currentNewsId === undefined || currentNewsId === null)
            throw new Error("The parameter 'currentNewsId' must be defined.");
        url_ = url_.replace("{currentNewsId}", encodeURIComponent("" + currentNewsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNews_GetNextNews(_response));
        });
    }

    protected processNews_GetNextNews(response: AxiosResponse): Promise<ListNewsModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ListNewsModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListNewsModel.fromJS(resultData200);
            return Promise.resolve<ListNewsModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListNewsModel>(null as any);
    }

    notification_GetPaging(pageNumber: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfNotificationModel> {
        let url_ = this.baseUrl + "/api/notification/getpaging?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNotification_GetPaging(_response));
        });
    }

    protected processNotification_GetPaging(response: AxiosResponse): Promise<PaginatedListOfNotificationModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfNotificationModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfNotificationModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfNotificationModel>(null as any);
    }

    notification_GetById(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<NotificationModel> {
        let url_ = this.baseUrl + "/api/notification/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNotification_GetById(_response));
        });
    }

    protected processNotification_GetById(response: AxiosResponse): Promise<NotificationModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NotificationModel.fromJS(resultData200);
            return Promise.resolve<NotificationModel>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result204);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NotificationModel>(null as any);
    }

    notification_CreateNotification(model: CreateNotificationModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/notification/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNotification_CreateNotification(_response));
        });
    }

    protected processNotification_CreateNotification(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateNotificationModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    notification_Filter(filterNotificationModel: FilterNotificationModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfNotificationModel> {
        let url_ = this.baseUrl + "/api/notification/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterNotificationModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNotification_Filter(_response));
        });
    }

    protected processNotification_Filter(response: AxiosResponse): Promise<PaginatedListOfNotificationModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = SortingNotificationModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfNotificationModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfNotificationModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfNotificationModel>(null as any);
    }

    notification_UpdateNotification(id: string | undefined, updateNotificationModel: UpdateNotificationModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/notification/update?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateNotificationModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNotification_UpdateNotification(_response));
        });
    }

    protected processNotification_UpdateNotification(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = UpdateNotificationModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    notification_PostNotification(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/notification/postnotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNotification_PostNotification(_response));
        });
    }

    protected processNotification_PostNotification(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = UpdateNotificationModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    notification_UnPostNotification(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/notification/unpostnotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNotification_UnPostNotification(_response));
        });
    }

    protected processNotification_UnPostNotification(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = UpdateNotificationModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    notification_GetPagingByUser(pageNumber: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfNotificationUserModel> {
        let url_ = this.baseUrl + "/api/notification/getpagingbyuser?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNotification_GetPagingByUser(_response));
        });
    }

    protected processNotification_GetPagingByUser(response: AxiosResponse): Promise<PaginatedListOfNotificationUserModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfNotificationUserModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfNotificationUserModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfNotificationUserModel>(null as any);
    }

    notification_GetCountNotificationByUser(isSeen: boolean | null | undefined , cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/notification/getcountnotificationbyuser?";
        if (isSeen !== undefined && isSeen !== null)
            url_ += "IsSeen=" + encodeURIComponent("" + isSeen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNotification_GetCountNotificationByUser(_response));
        });
    }

    protected processNotification_GetCountNotificationByUser(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    notification_RemoveNotificationByUser(id: string , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/notification/removenotificationbyuser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(id);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNotification_RemoveNotificationByUser(_response));
        });
    }

    protected processNotification_RemoveNotificationByUser(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateNotificationModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    notification_RemoveAllNotificationByUser(  cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/notification/removeallnotificationbyuser";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNotification_RemoveAllNotificationByUser(_response));
        });
    }

    protected processNotification_RemoveAllNotificationByUser(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateNotificationModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    notification_SeenNotificationByUser(listId: string[] , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/notification/seennotificationbyuser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processNotification_SeenNotificationByUser(_response));
        });
    }

    protected processNotification_SeenNotificationByUser(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateNotificationModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    photo_GetAllPhotoAttachments(attachmentType: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<AttachmentModel[]> {
        let url_ = this.baseUrl + "/api/photo/multiple?";
        if (attachmentType !== undefined && attachmentType !== null)
            url_ += "attachmentType=" + encodeURIComponent("" + attachmentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_GetAllPhotoAttachments(_response));
        });
    }

    protected processPhoto_GetAllPhotoAttachments(response: AxiosResponse): Promise<AttachmentModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AttachmentModel[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(AttachmentModel.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(AttachmentModel.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttachmentModel[]>(null as any);
    }

    photo_PostMultiplePhotoAttachment(files: FileParameter[] | null | undefined, attachmentType: string | null | undefined, referenceId: string | null | undefined, imageCategory: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/photo/multiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("Files", item_.data, item_.fileName ? item_.fileName : "Files") );
        if (attachmentType !== null && attachmentType !== undefined)
            content_.append("AttachmentType", attachmentType.toString());
        if (referenceId !== null && referenceId !== undefined)
            content_.append("ReferenceId", referenceId.toString());
        if (imageCategory !== null && imageCategory !== undefined)
            content_.append("ImageCategory", imageCategory.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_PostMultiplePhotoAttachment(_response));
        });
    }

    protected processPhoto_PostMultiplePhotoAttachment(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    photo_GetImagesByFilter(attachmentCollectionFilter: AttachmentCollectionFilterModel , cancelToken?: CancelToken | undefined): Promise<AttachmentModel[]> {
        let url_ = this.baseUrl + "/api/photo/getimagesbyfilter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(attachmentCollectionFilter);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_GetImagesByFilter(_response));
        });
    }

    protected processPhoto_GetImagesByFilter(response: AxiosResponse): Promise<AttachmentModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AttachmentModel[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(AttachmentModel.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(AttachmentModel.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttachmentModel[]>(null as any);
    }

    photo_GetPhotoByFileId(fileId: string, attachmentType: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<AttachmentModel[]> {
        let url_ = this.baseUrl + "/api/photo/single/{fileId}?";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        if (attachmentType !== undefined && attachmentType !== null)
            url_ += "attachmentType=" + encodeURIComponent("" + attachmentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_GetPhotoByFileId(_response));
        });
    }

    protected processPhoto_GetPhotoByFileId(response: AxiosResponse): Promise<AttachmentModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AttachmentModel[]>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(AttachmentModel.fromJS(item));
            }
            else {
                result404 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(AttachmentModel.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttachmentModel[]>(null as any);
    }

    photo_DeletePhotoById(fileId: string, attachmentType: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/photo/single/{fileId}?";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        if (attachmentType !== undefined && attachmentType !== null)
            url_ += "attachmentType=" + encodeURIComponent("" + attachmentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_DeletePhotoById(_response));
        });
    }

    protected processPhoto_DeletePhotoById(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    photo_PostPhotoAttachment(file: FileParameter | null | undefined, attachmentType: string | null | undefined, referenceId: string | null | undefined, imageCategory: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/photo/single";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (attachmentType !== null && attachmentType !== undefined)
            content_.append("AttachmentType", attachmentType.toString());
        if (referenceId !== null && referenceId !== undefined)
            content_.append("ReferenceId", referenceId.toString());
        if (imageCategory !== null && imageCategory !== undefined)
            content_.append("ImageCategory", imageCategory.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPhoto_PostPhotoAttachment(_response));
        });
    }

    protected processPhoto_PostPhotoAttachment(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = UploadMultipleFileRequestModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    profile_ChangePassword(request: ChangePasswordModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/profile/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProfile_ChangePassword(_response));
        });
    }

    protected processProfile_ChangePassword(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    profile_UpdateProfile(request: UpdateProfileModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/profile/update-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProfile_UpdateProfile(_response));
        });
    }

    protected processProfile_UpdateProfile(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    profile_ForgetPassword(request: ForgetPasswordModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/profile/forget-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProfile_ForgetPassword(_response));
        });
    }

    protected processProfile_ForgetPassword(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    profile_UserInfo(userName: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<UserResult> {
        let url_ = this.baseUrl + "/api/profile/profile?";
        if (userName !== undefined && userName !== null)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProfile_UserInfo(_response));
        });
    }

    protected processProfile_UserInfo(response: AxiosResponse): Promise<UserResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserResult.fromJS(resultData200);
            return Promise.resolve<UserResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResult>(null as any);
    }

    profile_UserInfo2(  cancelToken?: CancelToken | undefined): Promise<UserResult> {
        let url_ = this.baseUrl + "/api/profile/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProfile_UserInfo2(_response));
        });
    }

    protected processProfile_UserInfo2(response: AxiosResponse): Promise<UserResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = Result.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserResult.fromJS(resultData200);
            return Promise.resolve<UserResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResult>(null as any);
    }

    project_Create(model: CreateProjectModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/project/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_Create(_response));
        });
    }

    protected processProject_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    project_GetById(id: string , cancelToken?: CancelToken | undefined): Promise<ProjectModel> {
        let url_ = this.baseUrl + "/api/project/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_GetById(_response));
        });
    }

    protected processProject_GetById(response: AxiosResponse): Promise<ProjectModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProjectModel.fromJS(resultData200);
            return Promise.resolve<ProjectModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectModel>(null as any);
    }

    project_GetAll(  cancelToken?: CancelToken | undefined): Promise<ProjectModel[]> {
        let url_ = this.baseUrl + "/api/project/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_GetAll(_response));
        });
    }

    protected processProject_GetAll(response: AxiosResponse): Promise<ProjectModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ProjectModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProjectModel[]>(null as any);
    }

    project_Delete(projectId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/project/delete?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_Delete(_response));
        });
    }

    protected processProject_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    project_Update(projectId: string | undefined, model: UpdateProjectModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/project/update?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_Update(_response));
        });
    }

    protected processProject_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    project_PagingProject(pagingModel: PagingProjectModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfProjectModel> {
        let url_ = this.baseUrl + "/api/project/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_PagingProject(_response));
        });
    }

    protected processProject_PagingProject(response: AxiosResponse): Promise<PaginatedListOfProjectModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfProjectModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfProjectModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfProjectModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfProjectModel>(null as any);
    }

    project_Search(model: SearchProjectModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfProjectModel> {
        let url_ = this.baseUrl + "/api/project/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_Search(_response));
        });
    }

    protected processProject_Search(response: AxiosResponse): Promise<PaginatedListOfProjectModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfProjectModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfProjectModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfProjectModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfProjectModel>(null as any);
    }

    project_CountViewProject(projectId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/project/countviewproject?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_CountViewProject(_response));
        });
    }

    protected processProject_CountViewProject(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    project_GetAdministrativeByProject(  cancelToken?: CancelToken | undefined): Promise<AdministrativeByProjectModel[]> {
        let url_ = this.baseUrl + "/api/project/getadministrativebyproject";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_GetAdministrativeByProject(_response));
        });
    }

    protected processProject_GetAdministrativeByProject(response: AxiosResponse): Promise<AdministrativeByProjectModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdministrativeByProjectModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AdministrativeByProjectModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AdministrativeByProjectModel[]>(null as any);
    }

    project_SuggestProject(keyword: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<SuggestSearchProjectModel[]> {
        let url_ = this.baseUrl + "/api/project/suggestproject?";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_SuggestProject(_response));
        });
    }

    protected processProject_SuggestProject(response: AxiosResponse): Promise<SuggestSearchProjectModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(SuggestSearchProjectModel.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SuggestSearchProjectModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SuggestSearchProjectModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SuggestSearchProjectModel[]>(null as any);
    }

    project_Post(projectId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/project/post?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_Post(_response));
        });
    }

    protected processProject_Post(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    project_UnPost(projectId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/project/unpost?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_UnPost(_response));
        });
    }

    protected processProject_UnPost(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    project_UnLock(projectId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/project/unlock?";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_UnLock(_response));
        });
    }

    protected processProject_UnLock(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    project_SearchForAdmin(model: SearchProjectForAdminModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfProjectModel> {
        let url_ = this.baseUrl + "/api/project/searchforadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProject_SearchForAdmin(_response));
        });
    }

    protected processProject_SearchForAdmin(response: AxiosResponse): Promise<PaginatedListOfProjectModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfProjectModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfProjectModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfProjectModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfProjectModel>(null as any);
    }

    property_Create(model: CreatePropertyModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_Create(_response));
        });
    }

    protected processProperty_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_SaveTemp(model: CreatePropertyModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/savetemp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_SaveTemp(_response));
        });
    }

    protected processProperty_SaveTemp(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_GetAll(  cancelToken?: CancelToken | undefined): Promise<ListPropertyModel[]> {
        let url_ = this.baseUrl + "/api/property/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_GetAll(_response));
        });
    }

    protected processProperty_GetAll(response: AxiosResponse): Promise<ListPropertyModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListPropertyModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ListPropertyModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListPropertyModel[]>(null as any);
    }

    property_FilterPropertyByUser(filterData: FilterPropertyByUserModel , cancelToken?: CancelToken | undefined): Promise<ListPropertyModel[]> {
        let url_ = this.baseUrl + "/api/property/filterpropertybyuser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterData);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_FilterPropertyByUser(_response));
        });
    }

    protected processProperty_FilterPropertyByUser(response: AxiosResponse): Promise<ListPropertyModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListPropertyModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ListPropertyModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListPropertyModel[]>(null as any);
    }

    property_GetAllBasicInfo(  cancelToken?: CancelToken | undefined): Promise<BasicPropertyModel[]> {
        let url_ = this.baseUrl + "/api/property/getallbasicinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_GetAllBasicInfo(_response));
        });
    }

    protected processProperty_GetAllBasicInfo(response: AxiosResponse): Promise<BasicPropertyModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BasicPropertyModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BasicPropertyModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BasicPropertyModel[]>(null as any);
    }

    property_GetById(id: string , cancelToken?: CancelToken | undefined): Promise<PropertyModel> {
        let url_ = this.baseUrl + "/api/property/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_GetById(_response));
        });
    }

    protected processProperty_GetById(response: AxiosResponse): Promise<PropertyModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PropertyModel.fromJS(resultData200);
            return Promise.resolve<PropertyModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyModel>(null as any);
    }

    property_GetByIdAdmin(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<PropertyModel> {
        let url_ = this.baseUrl + "/api/property/getbyidadmin?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_GetByIdAdmin(_response));
        });
    }

    protected processProperty_GetByIdAdmin(response: AxiosResponse): Promise<PropertyModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PropertyModel.fromJS(resultData200);
            return Promise.resolve<PropertyModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyModel>(null as any);
    }

    property_GetByListId(listId: string[] , cancelToken?: CancelToken | undefined): Promise<PropertyModel> {
        let url_ = this.baseUrl + "/api/property/getbylistid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listId);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_GetByListId(_response));
        });
    }

    protected processProperty_GetByListId(response: AxiosResponse): Promise<PropertyModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PropertyModel.fromJS(resultData200);
            return Promise.resolve<PropertyModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyModel>(null as any);
    }

    property_Update(propertyId: string | undefined, model: UpdatePropertyModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/update?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_Update(_response));
        });
    }

    protected processProperty_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_UpdatePropertyByUser(propertyId: string | undefined, model: CreatePropertyModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/updatepropertybyuser?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_UpdatePropertyByUser(_response));
        });
    }

    protected processProperty_UpdatePropertyByUser(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_ViewProperty(propertyId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/viewproperty?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_ViewProperty(_response));
        });
    }

    protected processProperty_ViewProperty(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_Approve(model: ApprovePropertyModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_Approve(_response));
        });
    }

    protected processProperty_Approve(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_Delete(propertyId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/delete?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_Delete(_response));
        });
    }

    protected processProperty_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_DeleteTempProperty(propertyId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/deletetempproperty?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_DeleteTempProperty(_response));
        });
    }

    protected processProperty_DeleteTempProperty(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_SearchAndSortProperty(searchModel: SearchingPropertyModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListPropertyModel> {
        let url_ = this.baseUrl + "/api/property/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_SearchAndSortProperty(_response));
        });
    }

    protected processProperty_SearchAndSortProperty(response: AxiosResponse): Promise<PaginatedListOfListPropertyModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListPropertyModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListPropertyModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListPropertyModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListPropertyModel>(null as any);
    }

    property_SearchAndSortPropertyForAdmin(searchModel: SearchingPropertyForAdminModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListPropertyModel> {
        let url_ = this.baseUrl + "/api/property/searchforadmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_SearchAndSortPropertyForAdmin(_response));
        });
    }

    protected processProperty_SearchAndSortPropertyForAdmin(response: AxiosResponse): Promise<PaginatedListOfListPropertyModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListPropertyModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListPropertyModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListPropertyModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListPropertyModel>(null as any);
    }

    property_SuggestProperty(keyword: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<SuggestSearchPropertyModel> {
        let url_ = this.baseUrl + "/api/property/suggestproperty?";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_SuggestProperty(_response));
        });
    }

    protected processProperty_SuggestProperty(response: AxiosResponse): Promise<SuggestSearchPropertyModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = SuggestSearchPropertyModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SuggestSearchPropertyModel.fromJS(resultData200);
            return Promise.resolve<SuggestSearchPropertyModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SuggestSearchPropertyModel>(null as any);
    }

    property_GetTotalCount(  cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/property/gettotalcount";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_GetTotalCount(_response));
        });
    }

    protected processProperty_GetTotalCount(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    property_GetNearest(model: PagingNearestPropertyModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListPropertyModel> {
        let url_ = this.baseUrl + "/api/property/getnearest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_GetNearest(_response));
        });
    }

    protected processProperty_GetNearest(response: AxiosResponse): Promise<PaginatedListOfListPropertyModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListPropertyModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListPropertyModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListPropertyModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListPropertyModel>(null as any);
    }

    property_PagingProperty(pagingModel: PagingPropertyModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListPropertyModel> {
        let url_ = this.baseUrl + "/api/property/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_PagingProperty(_response));
        });
    }

    protected processProperty_PagingProperty(response: AxiosResponse): Promise<PaginatedListOfListPropertyModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListPropertyModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListPropertyModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListPropertyModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListPropertyModel>(null as any);
    }

    property_UnPost(propertyId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/unpost?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_UnPost(_response));
        });
    }

    protected processProperty_UnPost(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    property_UnLock(propertyId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/property/unlock?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "propertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processProperty_UnLock(_response));
        });
    }

    protected processProperty_UnLock(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    propertyFavorite_Create(model: CreatePropertyFavoriteModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/propertyfavorite/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPropertyFavorite_Create(_response));
        });
    }

    protected processPropertyFavorite_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    propertyFavorite_PagingProperty(model: PagingPropertyFavoriteModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListPropertyModel> {
        let url_ = this.baseUrl + "/api/propertyfavorite/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPropertyFavorite_PagingProperty(_response));
        });
    }

    protected processPropertyFavorite_PagingProperty(response: AxiosResponse): Promise<PaginatedListOfListPropertyModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListPropertyModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListPropertyModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListPropertyModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListPropertyModel>(null as any);
    }

    propertyFavorite_Delete(propertyFavoriteId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/propertyfavorite/delete?";
        if (propertyFavoriteId === null)
            throw new Error("The parameter 'propertyFavoriteId' cannot be null.");
        else if (propertyFavoriteId !== undefined)
            url_ += "propertyFavoriteId=" + encodeURIComponent("" + propertyFavoriteId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPropertyFavorite_Delete(_response));
        });
    }

    protected processPropertyFavorite_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    propertyHeart_SendHeart(model: CreatePropertyHeartModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/propertyheart/sendheart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPropertyHeart_SendHeart(_response));
        });
    }

    protected processPropertyHeart_SendHeart(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    propertyHeart_PagingProperty(model: PagingPropertyHeartModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListPropertyHeartModel> {
        let url_ = this.baseUrl + "/api/propertyheart/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPropertyHeart_PagingProperty(_response));
        });
    }

    protected processPropertyHeart_PagingProperty(response: AxiosResponse): Promise<PaginatedListOfListPropertyHeartModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PagingPropertyHeartModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListPropertyHeartModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListPropertyHeartModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListPropertyHeartModel>(null as any);
    }

    propertyHeart_Delete(propertyHeartId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/propertyheart/delete?";
        if (propertyHeartId === null)
            throw new Error("The parameter 'propertyHeartId' cannot be null.");
        else if (propertyHeartId !== undefined)
            url_ += "propertyHeartId=" + encodeURIComponent("" + propertyHeartId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPropertyHeart_Delete(_response));
        });
    }

    protected processPropertyHeart_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    propertyHeart_IsPropertyHeart(model: CreatePropertyHeartModel , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/propertyheart/ispropertyheart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPropertyHeart_IsPropertyHeart(_response));
        });
    }

    protected processPropertyHeart_IsPropertyHeart(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    propertyHeart_IsManyPropertyHeart(userId: string, propertyIds: string[] , cancelToken?: CancelToken | undefined): Promise<boolean[]> {
        let url_ = this.baseUrl + "/api/propertyheart/ismanypropertyheart/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(propertyIds);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPropertyHeart_IsManyPropertyHeart(_response));
        });
    }

    protected processPropertyHeart_IsManyPropertyHeart(response: AxiosResponse): Promise<boolean[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<boolean[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(item);
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean[]>(null as any);
    }

    propertyMeetingNote_GetById(propertyId: string , cancelToken?: CancelToken | undefined): Promise<PropertyMeetingNoteModel> {
        let url_ = this.baseUrl + "/api/propertymeetingnote/getbyid/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPropertyMeetingNote_GetById(_response));
        });
    }

    protected processPropertyMeetingNote_GetById(response: AxiosResponse): Promise<PropertyMeetingNoteModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PropertyMeetingNoteModel.fromJS(resultData200);
            return Promise.resolve<PropertyMeetingNoteModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PropertyMeetingNoteModel>(null as any);
    }

    propertyNearest_Create(model: CreatePropertyNearestModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/propertynearest/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPropertyNearest_Create(_response));
        });
    }

    protected processPropertyNearest_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    propertyNearest_PagingProperty(model: PagingPropertyNearestModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfListPropertyModel> {
        let url_ = this.baseUrl + "/api/propertynearest/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPropertyNearest_PagingProperty(_response));
        });
    }

    protected processPropertyNearest_PagingProperty(response: AxiosResponse): Promise<PaginatedListOfListPropertyModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfListPropertyModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfListPropertyModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfListPropertyModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfListPropertyModel>(null as any);
    }

    propertyNearest_Delete(propertyNearestId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/propertynearest/delete?";
        if (propertyNearestId === null)
            throw new Error("The parameter 'propertyNearestId' cannot be null.");
        else if (propertyNearestId !== undefined)
            url_ += "propertyNearestId=" + encodeURIComponent("" + propertyNearestId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPropertyNearest_Delete(_response));
        });
    }

    protected processPropertyNearest_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    seller_GetById(userId: string , cancelToken?: CancelToken | undefined): Promise<ProfileInformationModel> {
        let url_ = this.baseUrl + "/api/seller/getbyid/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSeller_GetById(_response));
        });
    }

    protected processSeller_GetById(response: AxiosResponse): Promise<ProfileInformationModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfileInformationModel.fromJS(resultData200);
            return Promise.resolve<ProfileInformationModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfileInformationModel>(null as any);
    }

    seller_Update(profileId: string | undefined, model: UpdateProfileInformationModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/seller/update?";
        if (profileId === null)
            throw new Error("The parameter 'profileId' cannot be null.");
        else if (profileId !== undefined)
            url_ += "profileId=" + encodeURIComponent("" + profileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSeller_Update(_response));
        });
    }

    protected processSeller_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    seller_PagingSeller(pagingModel: PagingSellerModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfProfileInformationModel> {
        let url_ = this.baseUrl + "/api/seller/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSeller_PagingSeller(_response));
        });
    }

    protected processSeller_PagingSeller(response: AxiosResponse): Promise<PaginatedListOfProfileInformationModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfProfileInformationModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfProfileInformationModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfProfileInformationModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfProfileInformationModel>(null as any);
    }

    socialNetwork_Create(model: CreateSocialNetworkModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/socialnetwork/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_Create(_response));
        });
    }

    protected processSocialNetwork_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    socialNetwork_GetById(id: string , cancelToken?: CancelToken | undefined): Promise<SocialNetworkModel> {
        let url_ = this.baseUrl + "/api/socialnetwork/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_GetById(_response));
        });
    }

    protected processSocialNetwork_GetById(response: AxiosResponse): Promise<SocialNetworkModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SocialNetworkModel.fromJS(resultData200);
            return Promise.resolve<SocialNetworkModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SocialNetworkModel>(null as any);
    }

    socialNetwork_Delete(socialNetworkId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/socialnetwork/delete?";
        if (socialNetworkId === null)
            throw new Error("The parameter 'socialNetworkId' cannot be null.");
        else if (socialNetworkId !== undefined)
            url_ += "socialNetworkId=" + encodeURIComponent("" + socialNetworkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_Delete(_response));
        });
    }

    protected processSocialNetwork_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    socialNetwork_Update(socialNetworkId: string | undefined, model: CreateSocialNetworkModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/socialnetwork/update?";
        if (socialNetworkId === null)
            throw new Error("The parameter 'socialNetworkId' cannot be null.");
        else if (socialNetworkId !== undefined)
            url_ += "socialNetworkId=" + encodeURIComponent("" + socialNetworkId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_Update(_response));
        });
    }

    protected processSocialNetwork_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    socialNetwork_PagingSocialNetwork(pagingModel: PagingSocialNetworkModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfSocialNetworkModel> {
        let url_ = this.baseUrl + "/api/socialnetwork/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSocialNetwork_PagingSocialNetwork(_response));
        });
    }

    protected processSocialNetwork_PagingSocialNetwork(response: AxiosResponse): Promise<PaginatedListOfSocialNetworkModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfSocialNetworkModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfSocialNetworkModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfSocialNetworkModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfSocialNetworkModel>(null as any);
    }

    supplier_GetById(userId: string , cancelToken?: CancelToken | undefined): Promise<ProfileInformationModel> {
        let url_ = this.baseUrl + "/api/supplier/getbyid/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSupplier_GetById(_response));
        });
    }

    protected processSupplier_GetById(response: AxiosResponse): Promise<ProfileInformationModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProfileInformationModel.fromJS(resultData200);
            return Promise.resolve<ProfileInformationModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProfileInformationModel>(null as any);
    }

    supplier_Update(profileId: string | undefined, model: UpdateProfileInformationModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/supplier/update?";
        if (profileId === null)
            throw new Error("The parameter 'profileId' cannot be null.");
        else if (profileId !== undefined)
            url_ += "profileId=" + encodeURIComponent("" + profileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSupplier_Update(_response));
        });
    }

    protected processSupplier_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    supplier_PagingSupplier(pagingModel: PagingSupplierModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfProfileInformationModel> {
        let url_ = this.baseUrl + "/api/supplier/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processSupplier_PagingSupplier(_response));
        });
    }

    protected processSupplier_PagingSupplier(response: AxiosResponse): Promise<PaginatedListOfProfileInformationModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfProfileInformationModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfProfileInformationModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfProfileInformationModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfProfileInformationModel>(null as any);
    }

    timeForPost_Create(model: CreateTimeForPostModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/timeforpost/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTimeForPost_Create(_response));
        });
    }

    protected processTimeForPost_Create(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    timeForPost_GetById(id: string , cancelToken?: CancelToken | undefined): Promise<TimeForPostModel> {
        let url_ = this.baseUrl + "/api/timeforpost/getbyid/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTimeForPost_GetById(_response));
        });
    }

    protected processTimeForPost_GetById(response: AxiosResponse): Promise<TimeForPostModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TimeForPostModel.fromJS(resultData200);
            return Promise.resolve<TimeForPostModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TimeForPostModel>(null as any);
    }

    timeForPost_GetAll(  cancelToken?: CancelToken | undefined): Promise<TimeForPostModel[]> {
        let url_ = this.baseUrl + "/api/timeforpost/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTimeForPost_GetAll(_response));
        });
    }

    protected processTimeForPost_GetAll(response: AxiosResponse): Promise<TimeForPostModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimeForPostModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TimeForPostModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TimeForPostModel[]>(null as any);
    }

    timeForPost_Delete(timeForPostId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/timeforpost/delete?";
        if (timeForPostId === null)
            throw new Error("The parameter 'timeForPostId' cannot be null.");
        else if (timeForPostId !== undefined)
            url_ += "timeForPostId=" + encodeURIComponent("" + timeForPostId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTimeForPost_Delete(_response));
        });
    }

    protected processTimeForPost_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    timeForPost_Update(timeForPostId: string | undefined, model: CreateTimeForPostModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/timeforpost/update?";
        if (timeForPostId === null)
            throw new Error("The parameter 'timeForPostId' cannot be null.");
        else if (timeForPostId !== undefined)
            url_ += "timeForPostId=" + encodeURIComponent("" + timeForPostId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTimeForPost_Update(_response));
        });
    }

    protected processTimeForPost_Update(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    timeForPost_PagingTimeForPost(pagingModel: PagingTimeForPostModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfTimeForPostModel> {
        let url_ = this.baseUrl + "/api/timeforpost/getpaging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagingModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processTimeForPost_PagingTimeForPost(_response));
        });
    }

    protected processTimeForPost_PagingTimeForPost(response: AxiosResponse): Promise<PaginatedListOfTimeForPostModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = PaginatedListOfTimeForPostModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfTimeForPostModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfTimeForPostModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfTimeForPostModel>(null as any);
    }

    user_Login(request: LoginUserModel , cancelToken?: CancelToken | undefined): Promise<IdentityResult> {
        let url_ = this.baseUrl + "/api/user/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_Login(_response));
        });
    }

    protected processUser_Login(response: AxiosResponse): Promise<IdentityResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = IdentityResult.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityResult.fromJS(resultData200);
            return Promise.resolve<IdentityResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityResult>(null as any);
    }

    user_Logout(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_Logout(_response));
        });
    }

    protected processUser_Logout(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    user_RefreshToken(request: RefreshTokenModel , cancelToken?: CancelToken | undefined): Promise<IdentityResult> {
        let url_ = this.baseUrl + "/api/user/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_RefreshToken(_response));
        });
    }

    protected processUser_RefreshToken(response: AxiosResponse): Promise<IdentityResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityResult.fromJS(resultData200);
            return Promise.resolve<IdentityResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityResult>(null as any);
    }

    user_GetUserInfo(  cancelToken?: CancelToken | undefined): Promise<IdentityResult> {
        let url_ = this.baseUrl + "/api/user/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_GetUserInfo(_response));
        });
    }

    protected processUser_GetUserInfo(response: AxiosResponse): Promise<IdentityResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IdentityResult.fromJS(resultData200);
            return Promise.resolve<IdentityResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdentityResult>(null as any);
    }

    user_VerifyAccount(request: VerifyAccountModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/user/verifyaccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_VerifyAccount(_response));
        });
    }

    protected processUser_VerifyAccount(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    user_ForgetPassword(request: ForgetPasswordModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/user/forget-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_ForgetPassword(_response));
        });
    }

    protected processUser_ForgetPassword(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    user_ResetPassword(request: ResetPasswordModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/user/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_ResetPassword(_response));
        });
    }

    protected processUser_ResetPassword(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    user_Register(request: RegisterModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/user/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_Register(_response));
        });
    }

    protected processUser_Register(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    user_Delete(userId: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/user/delete?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUser_Delete(_response));
        });
    }

    protected processUser_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204  = _responseText;
            result204 = Result.fromJS(resultData204);
            return Promise.resolve<Result>(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    userSavedSearch_CreateSavedSearch(model: CreateUserSavedSearchModel , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/usersavedsearch/createsavedsearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUserSavedSearch_CreateSavedSearch(_response));
        });
    }

    protected processUserSavedSearch_CreateSavedSearch(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CreateUserSavedSearchModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    userSavedSearch_Sorting(sortingUserSavedSearchModel: SortingUserSavedSearchModel , cancelToken?: CancelToken | undefined): Promise<PaginatedListOfUserSavedSearchModel> {
        let url_ = this.baseUrl + "/api/usersavedsearch/sorting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sortingUserSavedSearchModel);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUserSavedSearch_Sorting(_response));
        });
    }

    protected processUserSavedSearch_Sorting(response: AxiosResponse): Promise<PaginatedListOfUserSavedSearchModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = SortingUserSavedSearchModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedListOfUserSavedSearchModel.fromJS(resultData200);
            return Promise.resolve<PaginatedListOfUserSavedSearchModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedListOfUserSavedSearchModel>(null as any);
    }

    userSavedSearch_Delete(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/usersavedsearch/delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUserSavedSearch_Delete(_response));
        });
    }

    protected processUserSavedSearch_Delete(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }

    userSavedSearch_DeleteAll(  cancelToken?: CancelToken | undefined): Promise<Result> {
        let url_ = this.baseUrl + "/api/usersavedsearch/deleteall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUserSavedSearch_DeleteAll(_response));
        });
    }

    protected processUserSavedSearch_DeleteAll(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);

        } else if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return Promise.resolve<Result>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class UserResult implements IUserResult {
    id?: string | undefined;
    email?: string | undefined;
    userName?: string | undefined;
    lockoutEnabled?: boolean;
    emailConfirmed?: boolean;
    roleName?: string | undefined;
    personalInformation?: ProfileInformationModel | undefined;

    constructor(data?: IUserResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.roleName = _data["roleName"];
            this.personalInformation = _data["personalInformation"] ? ProfileInformationModel.fromJS(_data["personalInformation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["emailConfirmed"] = this.emailConfirmed;
        data["roleName"] = this.roleName;
        data["personalInformation"] = this.personalInformation ? this.personalInformation.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserResult {
    id?: string | undefined;
    email?: string | undefined;
    userName?: string | undefined;
    lockoutEnabled?: boolean;
    emailConfirmed?: boolean;
    roleName?: string | undefined;
    personalInformation?: ProfileInformationModel | undefined;
}

export abstract class AuditableModel implements IAuditableModel {
    createTime?: Date;
    createBy?: string | undefined;
    updateTime?: Date | undefined;
    updateBy?: string | undefined;
    isDeleted?: DeletedStatus;
    currentState?: number;

    constructor(data?: IAuditableModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.createBy = _data["createBy"];
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
            this.updateBy = _data["updateBy"];
            this.isDeleted = _data["isDeleted"];
            this.currentState = _data["currentState"];
        }
    }

    static fromJS(data: any): AuditableModel {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableModel' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["createBy"] = this.createBy;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["updateBy"] = this.updateBy;
        data["isDeleted"] = this.isDeleted;
        data["currentState"] = this.currentState;
        return data;
    }
}

export interface IAuditableModel {
    createTime?: Date;
    createBy?: string | undefined;
    updateTime?: Date | undefined;
    updateBy?: string | undefined;
    isDeleted?: DeletedStatus;
    currentState?: number;
}

export class ProfileInformationModel extends AuditableModel implements IProfileInformationModel {
    id?: string;
    userId?: string;
    avatar?: string | undefined;
    avatarUrl?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    address?: string | undefined;
    descriptions?: string | undefined;
    birthDay?: Date;
    genderType?: GenderType;
    status?: ActiveStatus;
    roleName?: string | undefined;
    agency?: string | undefined;
    license?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    propertyCount?: number | undefined;
    socialNetworks?: SocialNetworkUserModel[] | undefined;

    constructor(data?: IProfileInformationModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.avatar = _data["avatar"];
            this.avatarUrl = _data["avatarUrl"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber1 = _data["phoneNumber1"];
            this.phoneNumber2 = _data["phoneNumber2"];
            this.phoneNumber3 = _data["phoneNumber3"];
            this.address = _data["address"];
            this.descriptions = _data["descriptions"];
            this.birthDay = _data["birthDay"] ? new Date(_data["birthDay"].toString()) : <any>undefined;
            this.genderType = _data["genderType"];
            this.status = _data["status"];
            this.roleName = _data["roleName"];
            this.agency = _data["agency"];
            this.license = _data["license"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.propertyCount = _data["propertyCount"];
            if (Array.isArray(_data["socialNetworks"])) {
                this.socialNetworks = [] as any;
                for (let item of _data["socialNetworks"])
                    this.socialNetworks!.push(SocialNetworkUserModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProfileInformationModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileInformationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["avatar"] = this.avatar;
        data["avatarUrl"] = this.avatarUrl;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber1"] = this.phoneNumber1;
        data["phoneNumber2"] = this.phoneNumber2;
        data["phoneNumber3"] = this.phoneNumber3;
        data["address"] = this.address;
        data["descriptions"] = this.descriptions;
        data["birthDay"] = this.birthDay ? this.birthDay.toISOString() : <any>undefined;
        data["genderType"] = this.genderType;
        data["status"] = this.status;
        data["roleName"] = this.roleName;
        data["agency"] = this.agency;
        data["license"] = this.license;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["propertyCount"] = this.propertyCount;
        if (Array.isArray(this.socialNetworks)) {
            data["socialNetworks"] = [];
            for (let item of this.socialNetworks)
                data["socialNetworks"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IProfileInformationModel extends IAuditableModel {
    id?: string;
    userId?: string;
    avatar?: string | undefined;
    avatarUrl?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    address?: string | undefined;
    descriptions?: string | undefined;
    birthDay?: Date;
    genderType?: GenderType;
    status?: ActiveStatus;
    roleName?: string | undefined;
    agency?: string | undefined;
    license?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    propertyCount?: number | undefined;
    socialNetworks?: SocialNetworkUserModel[] | undefined;
}

export enum GenderType {
    Male = 1,
    Female = 2,
    Other = 3,
}

export enum ActiveStatus {
    Active = 1,
    InActive = 2,
    All = 3,
}

export class SocialNetworkUserModel extends AuditableModel implements ISocialNetworkUserModel {
    id?: string;
    socialNetworkId?: string;
    profileId?: string;
    socialNetworkName?: string | undefined;
    socialNetwokIcon?: string | undefined;
    socialNetworkIconUrl?: string | undefined;

    constructor(data?: ISocialNetworkUserModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.socialNetworkId = _data["socialNetworkId"];
            this.profileId = _data["profileId"];
            this.socialNetworkName = _data["socialNetworkName"];
            this.socialNetwokIcon = _data["socialNetwokIcon"];
            this.socialNetworkIconUrl = _data["socialNetworkIconUrl"];
        }
    }

    static fromJS(data: any): SocialNetworkUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new SocialNetworkUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["socialNetworkId"] = this.socialNetworkId;
        data["profileId"] = this.profileId;
        data["socialNetworkName"] = this.socialNetworkName;
        data["socialNetwokIcon"] = this.socialNetwokIcon;
        data["socialNetworkIconUrl"] = this.socialNetworkIconUrl;
        super.toJSON(data);
        return data;
    }
}

export interface ISocialNetworkUserModel extends IAuditableModel {
    id?: string;
    socialNetworkId?: string;
    profileId?: string;
    socialNetworkName?: string | undefined;
    socialNetwokIcon?: string | undefined;
    socialNetworkIconUrl?: string | undefined;
}

export enum DeletedStatus {
    False = 1,
    True = 2,
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = this.extensions[key];
            }
        }
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export class UserModel implements IUserModel {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    descriptions?: string | undefined;
    employee?: string | undefined;
    phoneNumber?: string | undefined;
    isDelete?: boolean;
    isVerify?: boolean;
    roleId?: string | undefined;
    role?: string | undefined;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.descriptions = _data["descriptions"];
            this.employee = _data["employee"];
            this.phoneNumber = _data["phoneNumber"];
            this.isDelete = _data["isDelete"];
            this.isVerify = _data["isVerify"];
            this.roleId = _data["roleId"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["descriptions"] = this.descriptions;
        data["employee"] = this.employee;
        data["phoneNumber"] = this.phoneNumber;
        data["isDelete"] = this.isDelete;
        data["isVerify"] = this.isVerify;
        data["roleId"] = this.roleId;
        data["role"] = this.role;
        return data;
    }
}

export interface IUserModel {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    descriptions?: string | undefined;
    employee?: string | undefined;
    phoneNumber?: string | undefined;
    isDelete?: boolean;
    isVerify?: boolean;
    roleId?: string | undefined;
    role?: string | undefined;
}

export class CreateUserResult implements ICreateUserResult {
    email?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ICreateUserResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ICreateUserResult {
    email?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
}

export class CreateUserModel implements ICreateUserModel {
    email!: string;
    userName!: string;
    phoneNumber!: string;
    roleDefinitionId?: string | undefined;
    lastName?: string | undefined;
    sirName?: string | undefined;
    fullName?: string | undefined;
    address?: string | undefined;
    avatar?: string | undefined;
    birthDay?: Date;
    status?: ActiveStatus;
    genderType?: GenderType;
    levelDefinitionId?: string | undefined;
    titleReferenceId?: string | undefined;
    distributorId?: string | undefined;

    constructor(data?: ICreateUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.phoneNumber = _data["phoneNumber"];
            this.roleDefinitionId = _data["roleDefinitionId"];
            this.lastName = _data["lastName"];
            this.sirName = _data["sirName"];
            this.fullName = _data["fullName"];
            this.address = _data["address"];
            this.avatar = _data["avatar"];
            this.birthDay = _data["birthDay"] ? new Date(_data["birthDay"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.genderType = _data["genderType"];
            this.levelDefinitionId = _data["levelDefinitionId"];
            this.titleReferenceId = _data["titleReferenceId"];
            this.distributorId = _data["distributorId"];
        }
    }

    static fromJS(data: any): CreateUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["phoneNumber"] = this.phoneNumber;
        data["roleDefinitionId"] = this.roleDefinitionId;
        data["lastName"] = this.lastName;
        data["sirName"] = this.sirName;
        data["fullName"] = this.fullName;
        data["address"] = this.address;
        data["avatar"] = this.avatar;
        data["birthDay"] = this.birthDay ? this.birthDay.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["genderType"] = this.genderType;
        data["levelDefinitionId"] = this.levelDefinitionId;
        data["titleReferenceId"] = this.titleReferenceId;
        data["distributorId"] = this.distributorId;
        return data;
    }
}

export interface ICreateUserModel {
    email: string;
    userName: string;
    phoneNumber: string;
    roleDefinitionId?: string | undefined;
    lastName?: string | undefined;
    sirName?: string | undefined;
    fullName?: string | undefined;
    address?: string | undefined;
    avatar?: string | undefined;
    birthDay?: Date;
    status?: ActiveStatus;
    genderType?: GenderType;
    levelDefinitionId?: string | undefined;
    titleReferenceId?: string | undefined;
    distributorId?: string | undefined;
}

export class Result implements IResult {
    succeeded?: boolean;
    errors?: string[] | undefined;
    objectReturn?: any | undefined;

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.objectReturn = _data["objectReturn"];
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["objectReturn"] = this.objectReturn;
        return data;
    }
}

export interface IResult {
    succeeded?: boolean;
    errors?: string[] | undefined;
    objectReturn?: any | undefined;
}

export class CreateInternalUserModel implements ICreateInternalUserModel {
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    departmentId?: string;
    notes?: string | undefined;
    accountGroupId?: string;
    gender?: GenderType | undefined;

    constructor(data?: ICreateInternalUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.fullName = _data["fullName"];
            this.departmentId = _data["departmentId"];
            this.notes = _data["notes"];
            this.accountGroupId = _data["accountGroupId"];
            this.gender = _data["gender"];
        }
    }

    static fromJS(data: any): CreateInternalUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInternalUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["fullName"] = this.fullName;
        data["departmentId"] = this.departmentId;
        data["notes"] = this.notes;
        data["accountGroupId"] = this.accountGroupId;
        data["gender"] = this.gender;
        return data;
    }
}

export interface ICreateInternalUserModel {
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    departmentId?: string;
    notes?: string | undefined;
    accountGroupId?: string;
    gender?: GenderType | undefined;
}

export class ResetPasswordResult implements IResetPasswordResult {
    email?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: IResetPasswordResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ResetPasswordResult {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface IResetPasswordResult {
    email?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
}

export class LockUserModel implements ILockUserModel {
    userId!: string;

    constructor(data?: ILockUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): LockUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new LockUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface ILockUserModel {
    userId: string;
}

export class RoleModel implements IRoleModel {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: IRoleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRoleModel {
    id?: string | undefined;
    name?: string | undefined;
}

export class AttachmentTypeModel implements IAttachmentTypeModel {
    id?: string;
    name?: string | undefined;
    created?: Date;
    lastModified?: Date;

    constructor(data?: IAttachmentTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AttachmentTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAttachmentTypeModel {
    id?: string;
    name?: string | undefined;
    created?: Date;
    lastModified?: Date;
}

export class CreateBannerModel implements ICreateBannerModel {
    bannerName?: string | undefined;
    bannerType?: BannerTypes | undefined;
    imageUrl?: string | undefined;
    imagePathUrl?: string | undefined;
    descriptions?: string | undefined;
    bannerOrder?: number | undefined;

    constructor(data?: ICreateBannerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bannerName = _data["bannerName"];
            this.bannerType = _data["bannerType"];
            this.imageUrl = _data["imageUrl"];
            this.imagePathUrl = _data["imagePathUrl"];
            this.descriptions = _data["descriptions"];
            this.bannerOrder = _data["bannerOrder"];
        }
    }

    static fromJS(data: any): CreateBannerModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBannerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bannerName"] = this.bannerName;
        data["bannerType"] = this.bannerType;
        data["imageUrl"] = this.imageUrl;
        data["imagePathUrl"] = this.imagePathUrl;
        data["descriptions"] = this.descriptions;
        data["bannerOrder"] = this.bannerOrder;
        return data;
    }
}

export interface ICreateBannerModel {
    bannerName?: string | undefined;
    bannerType?: BannerTypes | undefined;
    imageUrl?: string | undefined;
    imagePathUrl?: string | undefined;
    descriptions?: string | undefined;
    bannerOrder?: number | undefined;
}

export enum BannerTypes {
    HomePage = 1,
    ProjectPage = 2,
}

export class BannerModel implements IBannerModel {
    id?: string;
    bannerName?: string | undefined;
    bannerType?: BannerTypes | undefined;
    imageUrl?: string | undefined;
    imagePathUrl?: string | undefined;
    descriptions?: string | undefined;
    bannerOrder?: number | undefined;
    bannerTypeName?: string | undefined;
    createTime?: Date;

    constructor(data?: IBannerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bannerName = _data["bannerName"];
            this.bannerType = _data["bannerType"];
            this.imageUrl = _data["imageUrl"];
            this.imagePathUrl = _data["imagePathUrl"];
            this.descriptions = _data["descriptions"];
            this.bannerOrder = _data["bannerOrder"];
            this.bannerTypeName = _data["bannerTypeName"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BannerModel {
        data = typeof data === 'object' ? data : {};
        let result = new BannerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bannerName"] = this.bannerName;
        data["bannerType"] = this.bannerType;
        data["imageUrl"] = this.imageUrl;
        data["imagePathUrl"] = this.imagePathUrl;
        data["descriptions"] = this.descriptions;
        data["bannerOrder"] = this.bannerOrder;
        data["bannerTypeName"] = this.bannerTypeName;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBannerModel {
    id?: string;
    bannerName?: string | undefined;
    bannerType?: BannerTypes | undefined;
    imageUrl?: string | undefined;
    imagePathUrl?: string | undefined;
    descriptions?: string | undefined;
    bannerOrder?: number | undefined;
    bannerTypeName?: string | undefined;
    createTime?: Date;
}

export class ValidationProblemDetails extends ProblemDetails implements IValidationProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IValidationProblemDetails) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = this.errors[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; } | undefined;
}

export class PaginatedListOfBannerModel implements IPaginatedListOfBannerModel {
    items?: BannerModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfBannerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BannerModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfBannerModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfBannerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfBannerModel {
    items?: BannerModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PagingIndexModel implements IPagingIndexModel {
    pageNumber?: number | undefined;
    pageSize?: number | undefined;

    constructor(data?: IPagingIndexModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
        }
    }

    static fromJS(data: any): PagingIndexModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingIndexModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        return data;
    }
}

export interface IPagingIndexModel {
    pageNumber?: number | undefined;
    pageSize?: number | undefined;
}

export class PagingBannerModel extends PagingIndexModel implements IPagingBannerModel {

    constructor(data?: IPagingBannerModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PagingBannerModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingBannerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPagingBannerModel extends IPagingIndexModel {
}

export class CreateConfigModel implements ICreateConfigModel {
    receiveEmailContactUs?: string | undefined;
    receiveEmailBookShowing?: string | undefined;
    host?: string | undefined;
    port?: number;
    userName?: string | undefined;
    password?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: ICreateConfigModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveEmailContactUs = _data["receiveEmailContactUs"];
            this.receiveEmailBookShowing = _data["receiveEmailBookShowing"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CreateConfigModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateConfigModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveEmailContactUs"] = this.receiveEmailContactUs;
        data["receiveEmailBookShowing"] = this.receiveEmailBookShowing;
        data["host"] = this.host;
        data["port"] = this.port;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICreateConfigModel {
    receiveEmailContactUs?: string | undefined;
    receiveEmailBookShowing?: string | undefined;
    host?: string | undefined;
    port?: number;
    userName?: string | undefined;
    password?: string | undefined;
    displayName?: string | undefined;
}

export class ConfigModel extends AuditableModel implements IConfigModel {
    id?: string;
    receiveEmailContactUs?: string | undefined;
    receiveEmailBookShowing?: string | undefined;
    host?: string | undefined;
    port?: number;
    userName?: string | undefined;
    password?: string | undefined;
    displayName?: string | undefined;
    listReceiveEmailContactUs?: string[] | undefined;
    listReceiveEmailBookShowing?: string[] | undefined;

    constructor(data?: IConfigModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.receiveEmailContactUs = _data["receiveEmailContactUs"];
            this.receiveEmailBookShowing = _data["receiveEmailBookShowing"];
            this.host = _data["host"];
            this.port = _data["port"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.displayName = _data["displayName"];
            if (Array.isArray(_data["listReceiveEmailContactUs"])) {
                this.listReceiveEmailContactUs = [] as any;
                for (let item of _data["listReceiveEmailContactUs"])
                    this.listReceiveEmailContactUs!.push(item);
            }
            if (Array.isArray(_data["listReceiveEmailBookShowing"])) {
                this.listReceiveEmailBookShowing = [] as any;
                for (let item of _data["listReceiveEmailBookShowing"])
                    this.listReceiveEmailBookShowing!.push(item);
            }
        }
    }

    static fromJS(data: any): ConfigModel {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["receiveEmailContactUs"] = this.receiveEmailContactUs;
        data["receiveEmailBookShowing"] = this.receiveEmailBookShowing;
        data["host"] = this.host;
        data["port"] = this.port;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["displayName"] = this.displayName;
        if (Array.isArray(this.listReceiveEmailContactUs)) {
            data["listReceiveEmailContactUs"] = [];
            for (let item of this.listReceiveEmailContactUs)
                data["listReceiveEmailContactUs"].push(item);
        }
        if (Array.isArray(this.listReceiveEmailBookShowing)) {
            data["listReceiveEmailBookShowing"] = [];
            for (let item of this.listReceiveEmailBookShowing)
                data["listReceiveEmailBookShowing"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IConfigModel extends IAuditableModel {
    id?: string;
    receiveEmailContactUs?: string | undefined;
    receiveEmailBookShowing?: string | undefined;
    host?: string | undefined;
    port?: number;
    userName?: string | undefined;
    password?: string | undefined;
    displayName?: string | undefined;
    listReceiveEmailContactUs?: string[] | undefined;
    listReceiveEmailBookShowing?: string[] | undefined;
}

export class CreateContactModel implements ICreateContactModel {
    subject?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    message?: string | undefined;
    propertyId?: string | undefined;
    projectId?: string | undefined;
    contactType?: ContactType;

    constructor(data?: ICreateContactModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.message = _data["message"];
            this.propertyId = _data["propertyId"];
            this.projectId = _data["projectId"];
            this.contactType = _data["contactType"];
        }
    }

    static fromJS(data: any): CreateContactModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["message"] = this.message;
        data["propertyId"] = this.propertyId;
        data["projectId"] = this.projectId;
        data["contactType"] = this.contactType;
        return data;
    }
}

export interface ICreateContactModel {
    subject?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    message?: string | undefined;
    propertyId?: string | undefined;
    projectId?: string | undefined;
    contactType?: ContactType;
}

export enum ContactType {
    Contact = 1,
    Question = 2,
    Email = 3,
    Book = 4,
}

export class ContactModel extends AuditableModel implements IContactModel {
    id?: string;
    subject?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    message?: string | undefined;
    contactType?: ContactType;

    constructor(data?: IContactModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.subject = _data["subject"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.message = _data["message"];
            this.contactType = _data["contactType"];
        }
    }

    static fromJS(data: any): ContactModel {
        data = typeof data === 'object' ? data : {};
        let result = new ContactModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subject"] = this.subject;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["message"] = this.message;
        data["contactType"] = this.contactType;
        super.toJSON(data);
        return data;
    }
}

export interface IContactModel extends IAuditableModel {
    id?: string;
    subject?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    message?: string | undefined;
    contactType?: ContactType;
}

export class PaginatedListOfContactModel implements IPaginatedListOfContactModel {
    items?: ContactModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfContactModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContactModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfContactModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfContactModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfContactModel {
    items?: ContactModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PagingContactModel extends PagingIndexModel implements IPagingContactModel {

    constructor(data?: IPagingContactModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PagingContactModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingContactModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPagingContactModel extends IPagingIndexModel {
}

export class ImageCategoryModel implements IImageCategoryModel {
    id?: string;
    name?: string | undefined;
    created?: Date;
    lastModified?: Date;

    constructor(data?: IImageCategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ImageCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImageCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface IImageCategoryModel {
    id?: string;
    name?: string | undefined;
    created?: Date;
    lastModified?: Date;
}

export class PropertyTypeModel implements IPropertyTypeModel {
    id?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;

    constructor(data?: IPropertyTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.propertyTypeVi = _data["propertyTypeVi"];
            this.propertyTypeEn = _data["propertyTypeEn"];
        }
    }

    static fromJS(data: any): PropertyTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyTypeVi"] = this.propertyTypeVi;
        data["propertyTypeEn"] = this.propertyTypeEn;
        return data;
    }
}

export interface IPropertyTypeModel {
    id?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
}

export class CreateNewsCategoryModel implements ICreateNewsCategoryModel {
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;

    constructor(data?: ICreateNewsCategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryNameVi = _data["categoryNameVi"];
            this.categoryNameEn = _data["categoryNameEn"];
        }
    }

    static fromJS(data: any): CreateNewsCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNewsCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryNameVi"] = this.categoryNameVi;
        data["categoryNameEn"] = this.categoryNameEn;
        return data;
    }
}

export interface ICreateNewsCategoryModel {
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
}

export class NewsCategoryModel extends AuditableModel implements INewsCategoryModel {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isApprove?: NewsApproveStatus | undefined;

    constructor(data?: INewsCategoryModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.categoryNameVi = _data["categoryNameVi"];
            this.categoryNameEn = _data["categoryNameEn"];
            this.isApprove = _data["isApprove"];
        }
    }

    static fromJS(data: any): NewsCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new NewsCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryNameVi"] = this.categoryNameVi;
        data["categoryNameEn"] = this.categoryNameEn;
        data["isApprove"] = this.isApprove;
        super.toJSON(data);
        return data;
    }
}

export interface INewsCategoryModel extends IAuditableModel {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isApprove?: NewsApproveStatus | undefined;
}

export enum NewsApproveStatus {
    New = 1,
    Active = 2,
    InActive = 3,
    Lock = 4,
}

export class ListNewsCategoryModel extends AuditableModel implements IListNewsCategoryModel {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isApprove?: NewsApproveStatus;
    isApproveName?: string | undefined;
    approveDate?: Date | undefined;

    constructor(data?: IListNewsCategoryModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.categoryNameVi = _data["categoryNameVi"];
            this.categoryNameEn = _data["categoryNameEn"];
            this.isApprove = _data["isApprove"];
            this.isApproveName = _data["isApproveName"];
            this.approveDate = _data["approveDate"] ? new Date(_data["approveDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ListNewsCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListNewsCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryNameVi"] = this.categoryNameVi;
        data["categoryNameEn"] = this.categoryNameEn;
        data["isApprove"] = this.isApprove;
        data["isApproveName"] = this.isApproveName;
        data["approveDate"] = this.approveDate ? this.approveDate.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IListNewsCategoryModel extends IAuditableModel {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    isApprove?: NewsApproveStatus;
    isApproveName?: string | undefined;
    approveDate?: Date | undefined;
}

export class PaginatedListOfListNewsCategoryModel implements IPaginatedListOfListNewsCategoryModel {
    items?: ListNewsCategoryModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfListNewsCategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ListNewsCategoryModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfListNewsCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfListNewsCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfListNewsCategoryModel {
    items?: ListNewsCategoryModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PagingNewsCategoryModel extends PagingIndexModel implements IPagingNewsCategoryModel {

    constructor(data?: IPagingNewsCategoryModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PagingNewsCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingNewsCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPagingNewsCategoryModel extends IPagingIndexModel {
}

export class SearchingNewsCategoryModel extends PagingIndexModel implements ISearchingNewsCategoryModel {
    title?: string | undefined;
    isApprove?: NewsApproveStatus | undefined;

    constructor(data?: ISearchingNewsCategoryModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.isApprove = _data["isApprove"];
        }
    }

    static fromJS(data: any): SearchingNewsCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchingNewsCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["isApprove"] = this.isApprove;
        super.toJSON(data);
        return data;
    }
}

export interface ISearchingNewsCategoryModel extends IPagingIndexModel {
    title?: string | undefined;
    isApprove?: NewsApproveStatus | undefined;
}

export class CreateNewsModel implements ICreateNewsModel {
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    keyword?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    categoryId?: string;
    imageUrl?: string | undefined;
    featured?: boolean | undefined;
    isHotNews?: boolean | undefined;
    isWellRead?: boolean | undefined;
    position?: number | undefined;

    constructor(data?: ICreateNewsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
            this.keyword = _data["keyword"];
            this.contentVi = _data["contentVi"];
            this.contentEn = _data["contentEn"];
            this.descriptionsVi = _data["descriptionsVi"];
            this.descriptionsEn = _data["descriptionsEn"];
            this.categoryId = _data["categoryId"];
            this.imageUrl = _data["imageUrl"];
            this.featured = _data["featured"];
            this.isHotNews = _data["isHotNews"];
            this.isWellRead = _data["isWellRead"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): CreateNewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        data["keyword"] = this.keyword;
        data["contentVi"] = this.contentVi;
        data["contentEn"] = this.contentEn;
        data["descriptionsVi"] = this.descriptionsVi;
        data["descriptionsEn"] = this.descriptionsEn;
        data["categoryId"] = this.categoryId;
        data["imageUrl"] = this.imageUrl;
        data["featured"] = this.featured;
        data["isHotNews"] = this.isHotNews;
        data["isWellRead"] = this.isWellRead;
        data["position"] = this.position;
        return data;
    }
}

export interface ICreateNewsModel {
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    keyword?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    categoryId?: string;
    imageUrl?: string | undefined;
    featured?: boolean | undefined;
    isHotNews?: boolean | undefined;
    isWellRead?: boolean | undefined;
    position?: number | undefined;
}

export class NewsModel extends AuditableModel implements INewsModel {
    id?: string;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    keyword?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    statusId?: number;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    categoryId?: string;
    imageUrl?: string | undefined;
    imagePathUrl?: string | undefined;
    categoryName?: string | undefined;
    featured?: boolean | undefined;
    isHotNews?: boolean | undefined;
    isWellRead?: boolean | undefined;
    viewCount?: number | undefined;
    isApprove?: NewsApproveStatus;
    approveDate?: Date | undefined;
    position?: number;
    category?: NewsCategoryModel | undefined;

    constructor(data?: INewsModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
            this.keyword = _data["keyword"];
            this.contentVi = _data["contentVi"];
            this.contentEn = _data["contentEn"];
            this.statusId = _data["statusId"];
            this.descriptionsVi = _data["descriptionsVi"];
            this.descriptionsEn = _data["descriptionsEn"];
            this.categoryId = _data["categoryId"];
            this.imageUrl = _data["imageUrl"];
            this.imagePathUrl = _data["imagePathUrl"];
            this.categoryName = _data["categoryName"];
            this.featured = _data["featured"];
            this.isHotNews = _data["isHotNews"];
            this.isWellRead = _data["isWellRead"];
            this.viewCount = _data["viewCount"];
            this.isApprove = _data["isApprove"];
            this.approveDate = _data["approveDate"] ? new Date(_data["approveDate"].toString()) : <any>undefined;
            this.position = _data["position"];
            this.category = _data["category"] ? NewsCategoryModel.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new NewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        data["keyword"] = this.keyword;
        data["contentVi"] = this.contentVi;
        data["contentEn"] = this.contentEn;
        data["statusId"] = this.statusId;
        data["descriptionsVi"] = this.descriptionsVi;
        data["descriptionsEn"] = this.descriptionsEn;
        data["categoryId"] = this.categoryId;
        data["imageUrl"] = this.imageUrl;
        data["imagePathUrl"] = this.imagePathUrl;
        data["categoryName"] = this.categoryName;
        data["featured"] = this.featured;
        data["isHotNews"] = this.isHotNews;
        data["isWellRead"] = this.isWellRead;
        data["viewCount"] = this.viewCount;
        data["isApprove"] = this.isApprove;
        data["approveDate"] = this.approveDate ? this.approveDate.toISOString() : <any>undefined;
        data["position"] = this.position;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface INewsModel extends IAuditableModel {
    id?: string;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    keyword?: string | undefined;
    contentVi?: string | undefined;
    contentEn?: string | undefined;
    statusId?: number;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    categoryId?: string;
    imageUrl?: string | undefined;
    imagePathUrl?: string | undefined;
    categoryName?: string | undefined;
    featured?: boolean | undefined;
    isHotNews?: boolean | undefined;
    isWellRead?: boolean | undefined;
    viewCount?: number | undefined;
    isApprove?: NewsApproveStatus;
    approveDate?: Date | undefined;
    position?: number;
    category?: NewsCategoryModel | undefined;
}

export class ListNewsModel extends AuditableModel implements IListNewsModel {
    id?: string;
    imageUrl?: string | undefined;
    imagePathUrl?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    categoryId?: string;
    featured?: boolean | undefined;
    isHotNews?: boolean | undefined;
    isWellRead?: boolean | undefined;
    viewCount?: number | undefined;
    isApprove?: NewsApproveStatus;
    approveDate?: Date | undefined;
    isApproveName?: string | undefined;
    category?: NewsCategoryModel | undefined;

    constructor(data?: IListNewsModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.imageUrl = _data["imageUrl"];
            this.imagePathUrl = _data["imagePathUrl"];
            this.descriptionsVi = _data["descriptionsVi"];
            this.descriptionsEn = _data["descriptionsEn"];
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
            this.categoryId = _data["categoryId"];
            this.featured = _data["featured"];
            this.isHotNews = _data["isHotNews"];
            this.isWellRead = _data["isWellRead"];
            this.viewCount = _data["viewCount"];
            this.isApprove = _data["isApprove"];
            this.approveDate = _data["approveDate"] ? new Date(_data["approveDate"].toString()) : <any>undefined;
            this.isApproveName = _data["isApproveName"];
            this.category = _data["category"] ? NewsCategoryModel.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ListNewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListNewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imageUrl"] = this.imageUrl;
        data["imagePathUrl"] = this.imagePathUrl;
        data["descriptionsVi"] = this.descriptionsVi;
        data["descriptionsEn"] = this.descriptionsEn;
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        data["categoryId"] = this.categoryId;
        data["featured"] = this.featured;
        data["isHotNews"] = this.isHotNews;
        data["isWellRead"] = this.isWellRead;
        data["viewCount"] = this.viewCount;
        data["isApprove"] = this.isApprove;
        data["approveDate"] = this.approveDate ? this.approveDate.toISOString() : <any>undefined;
        data["isApproveName"] = this.isApproveName;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IListNewsModel extends IAuditableModel {
    id?: string;
    imageUrl?: string | undefined;
    imagePathUrl?: string | undefined;
    descriptionsVi?: string | undefined;
    descriptionsEn?: string | undefined;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
    categoryId?: string;
    featured?: boolean | undefined;
    isHotNews?: boolean | undefined;
    isWellRead?: boolean | undefined;
    viewCount?: number | undefined;
    isApprove?: NewsApproveStatus;
    approveDate?: Date | undefined;
    isApproveName?: string | undefined;
    category?: NewsCategoryModel | undefined;
}

export class PaginatedListOfListNewsModel implements IPaginatedListOfListNewsModel {
    items?: ListNewsModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfListNewsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ListNewsModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfListNewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfListNewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfListNewsModel {
    items?: ListNewsModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PagingNewsModel extends PagingIndexModel implements IPagingNewsModel {

    constructor(data?: IPagingNewsModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PagingNewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingNewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPagingNewsModel extends IPagingIndexModel {
}

export class SearchingNewsModel extends PagingIndexModel implements ISearchingNewsModel {
    title?: string | undefined;

    constructor(data?: ISearchingNewsModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): SearchingNewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchingNewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        super.toJSON(data);
        return data;
    }
}

export interface ISearchingNewsModel extends IPagingIndexModel {
    title?: string | undefined;
}

export class SearchingNewsForAdminModel extends SearchingNewsModel implements ISearchingNewsForAdminModel {
    isApprove?: NewsApproveStatus | undefined;
    categoryId?: string | undefined;
    isHotNew?: boolean | undefined;

    constructor(data?: ISearchingNewsForAdminModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isApprove = _data["isApprove"];
            this.categoryId = _data["categoryId"];
            this.isHotNew = _data["isHotNew"];
        }
    }

    static fromJS(data: any): SearchingNewsForAdminModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchingNewsForAdminModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isApprove"] = this.isApprove;
        data["categoryId"] = this.categoryId;
        data["isHotNew"] = this.isHotNew;
        super.toJSON(data);
        return data;
    }
}

export interface ISearchingNewsForAdminModel extends ISearchingNewsModel {
    isApprove?: NewsApproveStatus | undefined;
    categoryId?: string | undefined;
    isHotNew?: boolean | undefined;
}

export class ListNewsGroupByCategoryModel extends AuditableModel implements IListNewsGroupByCategoryModel {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    news?: ListNewsModel[] | undefined;

    constructor(data?: IListNewsGroupByCategoryModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.categoryNameVi = _data["categoryNameVi"];
            this.categoryNameEn = _data["categoryNameEn"];
            if (Array.isArray(_data["news"])) {
                this.news = [] as any;
                for (let item of _data["news"])
                    this.news!.push(ListNewsModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListNewsGroupByCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListNewsGroupByCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryNameVi"] = this.categoryNameVi;
        data["categoryNameEn"] = this.categoryNameEn;
        if (Array.isArray(this.news)) {
            data["news"] = [];
            for (let item of this.news)
                data["news"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IListNewsGroupByCategoryModel extends IAuditableModel {
    id?: string;
    categoryNameVi?: string | undefined;
    categoryNameEn?: string | undefined;
    news?: ListNewsModel[] | undefined;
}

export class PaginatedListOfNewsModel implements IPaginatedListOfNewsModel {
    items?: NewsModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfNewsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NewsModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfNewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfNewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfNewsModel {
    items?: NewsModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PaginatedListOfNotificationModel implements IPaginatedListOfNotificationModel {
    items?: NotificationModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfNotificationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NotificationModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfNotificationModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfNotificationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfNotificationModel {
    items?: NotificationModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class NotificationModel implements INotificationModel {
    id?: string;
    title?: string | undefined;
    titleVi?: string | undefined;
    content?: string | undefined;
    contentVi?: string | undefined;
    link?: string | undefined;
    isPosted?: boolean;
    postedTime?: Date | undefined;
    numberOfDaysAgo?: number;
    postedBy?: string | undefined;

    constructor(data?: INotificationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.titleVi = _data["titleVi"];
            this.content = _data["content"];
            this.contentVi = _data["contentVi"];
            this.link = _data["link"];
            this.isPosted = _data["isPosted"];
            this.postedTime = _data["postedTime"] ? new Date(_data["postedTime"].toString()) : <any>undefined;
            this.numberOfDaysAgo = _data["numberOfDaysAgo"];
            this.postedBy = _data["postedBy"];
        }
    }

    static fromJS(data: any): NotificationModel {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["titleVi"] = this.titleVi;
        data["content"] = this.content;
        data["contentVi"] = this.contentVi;
        data["link"] = this.link;
        data["isPosted"] = this.isPosted;
        data["postedTime"] = this.postedTime ? this.postedTime.toISOString() : <any>undefined;
        data["numberOfDaysAgo"] = this.numberOfDaysAgo;
        data["postedBy"] = this.postedBy;
        return data;
    }
}

export interface INotificationModel {
    id?: string;
    title?: string | undefined;
    titleVi?: string | undefined;
    content?: string | undefined;
    contentVi?: string | undefined;
    link?: string | undefined;
    isPosted?: boolean;
    postedTime?: Date | undefined;
    numberOfDaysAgo?: number;
    postedBy?: string | undefined;
}

export class CreateNotificationModel implements ICreateNotificationModel {
    title?: string | undefined;
    titleVi?: string | undefined;
    content?: string | undefined;
    contentVi?: string | undefined;
    link?: string | undefined;
    isPosted?: boolean;

    constructor(data?: ICreateNotificationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.titleVi = _data["titleVi"];
            this.content = _data["content"];
            this.contentVi = _data["contentVi"];
            this.link = _data["link"];
            this.isPosted = _data["isPosted"];
        }
    }

    static fromJS(data: any): CreateNotificationModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNotificationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["titleVi"] = this.titleVi;
        data["content"] = this.content;
        data["contentVi"] = this.contentVi;
        data["link"] = this.link;
        data["isPosted"] = this.isPosted;
        return data;
    }
}

export interface ICreateNotificationModel {
    title?: string | undefined;
    titleVi?: string | undefined;
    content?: string | undefined;
    contentVi?: string | undefined;
    link?: string | undefined;
    isPosted?: boolean;
}

export class SortingNotificationModel implements ISortingNotificationModel {
    pageNumber?: number;
    pageSize?: number;
    newest?: boolean | undefined;
    oldest?: boolean | undefined;
    nameOrder?: boolean | undefined;
    nameOrderDescending?: boolean | undefined;

    constructor(data?: ISortingNotificationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.newest = _data["newest"];
            this.oldest = _data["oldest"];
            this.nameOrder = _data["nameOrder"];
            this.nameOrderDescending = _data["nameOrderDescending"];
        }
    }

    static fromJS(data: any): SortingNotificationModel {
        data = typeof data === 'object' ? data : {};
        let result = new SortingNotificationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["newest"] = this.newest;
        data["oldest"] = this.oldest;
        data["nameOrder"] = this.nameOrder;
        data["nameOrderDescending"] = this.nameOrderDescending;
        return data;
    }
}

export interface ISortingNotificationModel {
    pageNumber?: number;
    pageSize?: number;
    newest?: boolean | undefined;
    oldest?: boolean | undefined;
    nameOrder?: boolean | undefined;
    nameOrderDescending?: boolean | undefined;
}

export class FilterNotificationModel implements IFilterNotificationModel {
    pageNumber?: number;
    pageSize?: number;
    keyword?: string | undefined;
    isPosted?: boolean | undefined;

    constructor(data?: IFilterNotificationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.keyword = _data["keyword"];
            this.isPosted = _data["isPosted"];
        }
    }

    static fromJS(data: any): FilterNotificationModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilterNotificationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["keyword"] = this.keyword;
        data["isPosted"] = this.isPosted;
        return data;
    }
}

export interface IFilterNotificationModel {
    pageNumber?: number;
    pageSize?: number;
    keyword?: string | undefined;
    isPosted?: boolean | undefined;
}

export class UpdateNotificationModel implements IUpdateNotificationModel {
    title?: string | undefined;
    titleVi?: string | undefined;
    content?: string | undefined;
    contentVi?: string | undefined;
    link?: string | undefined;

    constructor(data?: IUpdateNotificationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.titleVi = _data["titleVi"];
            this.content = _data["content"];
            this.contentVi = _data["contentVi"];
            this.link = _data["link"];
        }
    }

    static fromJS(data: any): UpdateNotificationModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["titleVi"] = this.titleVi;
        data["content"] = this.content;
        data["contentVi"] = this.contentVi;
        data["link"] = this.link;
        return data;
    }
}

export interface IUpdateNotificationModel {
    title?: string | undefined;
    titleVi?: string | undefined;
    content?: string | undefined;
    contentVi?: string | undefined;
    link?: string | undefined;
}

export class PaginatedListOfNotificationUserModel implements IPaginatedListOfNotificationUserModel {
    items?: NotificationUserModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfNotificationUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NotificationUserModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfNotificationUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfNotificationUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfNotificationUserModel {
    items?: NotificationUserModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class NotificationUserModel implements INotificationUserModel {
    id?: string;
    title?: string | undefined;
    titleVi?: string | undefined;
    content?: string | undefined;
    contentVi?: string | undefined;
    link?: string | undefined;
    isPosted?: boolean;
    postedTime?: Date | undefined;
    numberOfDaysAgo?: number;
    postedBy?: string | undefined;
    isSeen?: boolean;

    constructor(data?: INotificationUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.titleVi = _data["titleVi"];
            this.content = _data["content"];
            this.contentVi = _data["contentVi"];
            this.link = _data["link"];
            this.isPosted = _data["isPosted"];
            this.postedTime = _data["postedTime"] ? new Date(_data["postedTime"].toString()) : <any>undefined;
            this.numberOfDaysAgo = _data["numberOfDaysAgo"];
            this.postedBy = _data["postedBy"];
            this.isSeen = _data["isSeen"];
        }
    }

    static fromJS(data: any): NotificationUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["titleVi"] = this.titleVi;
        data["content"] = this.content;
        data["contentVi"] = this.contentVi;
        data["link"] = this.link;
        data["isPosted"] = this.isPosted;
        data["postedTime"] = this.postedTime ? this.postedTime.toISOString() : <any>undefined;
        data["numberOfDaysAgo"] = this.numberOfDaysAgo;
        data["postedBy"] = this.postedBy;
        data["isSeen"] = this.isSeen;
        return data;
    }
}

export interface INotificationUserModel {
    id?: string;
    title?: string | undefined;
    titleVi?: string | undefined;
    content?: string | undefined;
    contentVi?: string | undefined;
    link?: string | undefined;
    isPosted?: boolean;
    postedTime?: Date | undefined;
    numberOfDaysAgo?: number;
    postedBy?: string | undefined;
    isSeen?: boolean;
}

export class AttachmentModel implements IAttachmentModel {
    id?: string;
    groupId?: string;
    fileName?: string | undefined;
    fileType?: string | undefined;
    filePath?: string | undefined;
    fileUrl?: string | undefined;
    fileSize?: number | undefined;
    created?: Date;
    attachmentTypeId?: string;
    attachmentType?: AttachmentTypeModel | undefined;
    serviceTypeId?: string;
    referenceId?: string | undefined;
    attachmentTypeName?: string | undefined;

    constructor(data?: IAttachmentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.groupId = _data["groupId"];
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.filePath = _data["filePath"];
            this.fileUrl = _data["fileUrl"];
            this.fileSize = _data["fileSize"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.attachmentTypeId = _data["attachmentTypeId"];
            this.attachmentType = _data["attachmentType"] ? AttachmentTypeModel.fromJS(_data["attachmentType"]) : <any>undefined;
            this.serviceTypeId = _data["serviceTypeId"];
            this.referenceId = _data["referenceId"];
            this.attachmentTypeName = _data["attachmentTypeName"];
        }
    }

    static fromJS(data: any): AttachmentModel {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupId"] = this.groupId;
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["filePath"] = this.filePath;
        data["fileUrl"] = this.fileUrl;
        data["fileSize"] = this.fileSize;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["attachmentTypeId"] = this.attachmentTypeId;
        data["attachmentType"] = this.attachmentType ? this.attachmentType.toJSON() : <any>undefined;
        data["serviceTypeId"] = this.serviceTypeId;
        data["referenceId"] = this.referenceId;
        data["attachmentTypeName"] = this.attachmentTypeName;
        return data;
    }
}

export interface IAttachmentModel {
    id?: string;
    groupId?: string;
    fileName?: string | undefined;
    fileType?: string | undefined;
    filePath?: string | undefined;
    fileUrl?: string | undefined;
    fileSize?: number | undefined;
    created?: Date;
    attachmentTypeId?: string;
    attachmentType?: AttachmentTypeModel | undefined;
    serviceTypeId?: string;
    referenceId?: string | undefined;
    attachmentTypeName?: string | undefined;
}

export class AttachmentCollectionFilterModel implements IAttachmentCollectionFilterModel {
    attachmentType?: string | undefined;
    serviceType?: string | undefined;
    referenceIds?: (string | undefined)[] | undefined;

    constructor(data?: IAttachmentCollectionFilterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attachmentType = _data["attachmentType"];
            this.serviceType = _data["serviceType"];
            if (Array.isArray(_data["referenceIds"])) {
                this.referenceIds = [] as any;
                for (let item of _data["referenceIds"])
                    this.referenceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): AttachmentCollectionFilterModel {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentCollectionFilterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attachmentType"] = this.attachmentType;
        data["serviceType"] = this.serviceType;
        if (Array.isArray(this.referenceIds)) {
            data["referenceIds"] = [];
            for (let item of this.referenceIds)
                data["referenceIds"].push(item);
        }
        return data;
    }
}

export interface IAttachmentCollectionFilterModel {
    attachmentType?: string | undefined;
    serviceType?: string | undefined;
    referenceIds?: (string | undefined)[] | undefined;
}

export class UploadMultipleFileRequestModel implements IUploadMultipleFileRequestModel {
    files?: string[] | undefined;
    attachmentType?: string | undefined;
    referenceId?: string | undefined;
    imageCategory?: string | undefined;

    constructor(data?: IUploadMultipleFileRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(item);
            }
            this.attachmentType = _data["attachmentType"];
            this.referenceId = _data["referenceId"];
            this.imageCategory = _data["imageCategory"];
        }
    }

    static fromJS(data: any): UploadMultipleFileRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UploadMultipleFileRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item);
        }
        data["attachmentType"] = this.attachmentType;
        data["referenceId"] = this.referenceId;
        data["imageCategory"] = this.imageCategory;
        return data;
    }
}

export interface IUploadMultipleFileRequestModel {
    files?: string[] | undefined;
    attachmentType?: string | undefined;
    referenceId?: string | undefined;
    imageCategory?: string | undefined;
}

export class ChangePasswordModel implements IChangePasswordModel {
    userName!: string;
    oldPassword!: string;
    newPassword!: string;
    confirmPassword?: string | undefined;

    constructor(data?: IChangePasswordModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IChangePasswordModel {
    userName: string;
    oldPassword: string;
    newPassword: string;
    confirmPassword?: string | undefined;
}

export class UpdateProfileModel implements IUpdateProfileModel {
    avatarFilePath?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    address?: string | undefined;

    constructor(data?: IUpdateProfileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.avatarFilePath = _data["avatarFilePath"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber1 = _data["phoneNumber1"];
            this.phoneNumber2 = _data["phoneNumber2"];
            this.phoneNumber3 = _data["phoneNumber3"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): UpdateProfileModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatarFilePath"] = this.avatarFilePath;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber1"] = this.phoneNumber1;
        data["phoneNumber2"] = this.phoneNumber2;
        data["phoneNumber3"] = this.phoneNumber3;
        data["address"] = this.address;
        return data;
    }
}

export interface IUpdateProfileModel {
    avatarFilePath?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    address?: string | undefined;
}

export class ForgetPasswordModel implements IForgetPasswordModel {
    email!: string;

    constructor(data?: IForgetPasswordModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgetPasswordModel {
        data = typeof data === 'object' ? data : {};
        let result = new ForgetPasswordModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgetPasswordModel {
    email: string;
}

export class CreateProjectModel implements ICreateProjectModel {
    propertyTypeId?: string | undefined;
    projectVi?: string | undefined;
    projectEn?: string | undefined;
    coverImage?: string | undefined;
    projectLogo?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    developer?: string | undefined;
    video?: string | undefined;
    virtualTour?: string | undefined;
    floorPlans?: string | undefined;
    mapViewImage?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    street?: string | undefined;
    descriptions?: string | undefined;
    longtitude?: string | undefined;
    latitude?: string | undefined;
    projectFeatures?: CreateProjectFeatureModel[] | undefined;
    projectImages?: CreateProjectImageModel[] | undefined;
    projectSellers?: CreateProjectSellerModel[] | undefined;

    constructor(data?: ICreateProjectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyTypeId = _data["propertyTypeId"];
            this.projectVi = _data["projectVi"];
            this.projectEn = _data["projectEn"];
            this.coverImage = _data["coverImage"];
            this.projectLogo = _data["projectLogo"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.developer = _data["developer"];
            this.video = _data["video"];
            this.virtualTour = _data["virtualTour"];
            this.floorPlans = _data["floorPlans"];
            this.mapViewImage = _data["mapViewImage"];
            this.provinceCode = _data["provinceCode"];
            this.districtCode = _data["districtCode"];
            this.wardCode = _data["wardCode"];
            this.street = _data["street"];
            this.descriptions = _data["descriptions"];
            this.longtitude = _data["longtitude"];
            this.latitude = _data["latitude"];
            if (Array.isArray(_data["projectFeatures"])) {
                this.projectFeatures = [] as any;
                for (let item of _data["projectFeatures"])
                    this.projectFeatures!.push(CreateProjectFeatureModel.fromJS(item));
            }
            if (Array.isArray(_data["projectImages"])) {
                this.projectImages = [] as any;
                for (let item of _data["projectImages"])
                    this.projectImages!.push(CreateProjectImageModel.fromJS(item));
            }
            if (Array.isArray(_data["projectSellers"])) {
                this.projectSellers = [] as any;
                for (let item of _data["projectSellers"])
                    this.projectSellers!.push(CreateProjectSellerModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyTypeId"] = this.propertyTypeId;
        data["projectVi"] = this.projectVi;
        data["projectEn"] = this.projectEn;
        data["coverImage"] = this.coverImage;
        data["projectLogo"] = this.projectLogo;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["developer"] = this.developer;
        data["video"] = this.video;
        data["virtualTour"] = this.virtualTour;
        data["floorPlans"] = this.floorPlans;
        data["mapViewImage"] = this.mapViewImage;
        data["provinceCode"] = this.provinceCode;
        data["districtCode"] = this.districtCode;
        data["wardCode"] = this.wardCode;
        data["street"] = this.street;
        data["descriptions"] = this.descriptions;
        data["longtitude"] = this.longtitude;
        data["latitude"] = this.latitude;
        if (Array.isArray(this.projectFeatures)) {
            data["projectFeatures"] = [];
            for (let item of this.projectFeatures)
                data["projectFeatures"].push(item.toJSON());
        }
        if (Array.isArray(this.projectImages)) {
            data["projectImages"] = [];
            for (let item of this.projectImages)
                data["projectImages"].push(item.toJSON());
        }
        if (Array.isArray(this.projectSellers)) {
            data["projectSellers"] = [];
            for (let item of this.projectSellers)
                data["projectSellers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateProjectModel {
    propertyTypeId?: string | undefined;
    projectVi?: string | undefined;
    projectEn?: string | undefined;
    coverImage?: string | undefined;
    projectLogo?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    developer?: string | undefined;
    video?: string | undefined;
    virtualTour?: string | undefined;
    floorPlans?: string | undefined;
    mapViewImage?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    street?: string | undefined;
    descriptions?: string | undefined;
    longtitude?: string | undefined;
    latitude?: string | undefined;
    projectFeatures?: CreateProjectFeatureModel[] | undefined;
    projectImages?: CreateProjectImageModel[] | undefined;
    projectSellers?: CreateProjectSellerModel[] | undefined;
}

export class CreateProjectFeatureModel implements ICreateProjectFeatureModel {
    projectFeatureId?: string | undefined;

    constructor(data?: ICreateProjectFeatureModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectFeatureId = _data["projectFeatureId"];
        }
    }

    static fromJS(data: any): CreateProjectFeatureModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectFeatureModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectFeatureId"] = this.projectFeatureId;
        return data;
    }
}

export interface ICreateProjectFeatureModel {
    projectFeatureId?: string | undefined;
}

export class CreateProjectImageModel implements ICreateProjectImageModel {
    name?: string | undefined;
    imagesPath?: string | undefined;

    constructor(data?: ICreateProjectImageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.imagesPath = _data["imagesPath"];
        }
    }

    static fromJS(data: any): CreateProjectImageModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectImageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["imagesPath"] = this.imagesPath;
        return data;
    }
}

export interface ICreateProjectImageModel {
    name?: string | undefined;
    imagesPath?: string | undefined;
}

export class CreateProjectSellerModel implements ICreateProjectSellerModel {
    userId?: string;

    constructor(data?: ICreateProjectSellerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CreateProjectSellerModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectSellerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface ICreateProjectSellerModel {
    userId?: string;
}

export class ProjectModel extends AuditableModel implements IProjectModel {
    id?: string;
    propertyTypeId?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
    projectVi?: string | undefined;
    projectEn?: string | undefined;
    coverImage?: string | undefined;
    coverImageUrl?: string | undefined;
    projectLogo?: string | undefined;
    projectLogoUrl?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    developer?: string | undefined;
    video?: string | undefined;
    virtualTour?: string | undefined;
    floorPlans?: string | undefined;
    mapViewImage?: string | undefined;
    mapViewImageUrl?: string | undefined;
    status?: ProjectStatus;
    statusName?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    provinceName?: string | undefined;
    districtName?: string | undefined;
    wardName?: string | undefined;
    street?: string | undefined;
    descriptions?: string | undefined;
    longtitude?: string | undefined;
    latitude?: string | undefined;
    viewCount?: number | undefined;
    isApprove?: ProjectApproveStatus;
    approveStatusName?: string | undefined;
    approveDate?: Date | undefined;
    projectFeatures?: ProjectFeatureModel[] | undefined;
    projectImages?: ProjectImageModel[] | undefined;
    projectSellers?: ProjectSellerModel[] | undefined;

    constructor(data?: IProjectModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.propertyTypeVi = _data["propertyTypeVi"];
            this.propertyTypeEn = _data["propertyTypeEn"];
            this.projectVi = _data["projectVi"];
            this.projectEn = _data["projectEn"];
            this.coverImage = _data["coverImage"];
            this.coverImageUrl = _data["coverImageUrl"];
            this.projectLogo = _data["projectLogo"];
            this.projectLogoUrl = _data["projectLogoUrl"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.developer = _data["developer"];
            this.video = _data["video"];
            this.virtualTour = _data["virtualTour"];
            this.floorPlans = _data["floorPlans"];
            this.mapViewImage = _data["mapViewImage"];
            this.mapViewImageUrl = _data["mapViewImageUrl"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.provinceCode = _data["provinceCode"];
            this.districtCode = _data["districtCode"];
            this.wardCode = _data["wardCode"];
            this.provinceName = _data["provinceName"];
            this.districtName = _data["districtName"];
            this.wardName = _data["wardName"];
            this.street = _data["street"];
            this.descriptions = _data["descriptions"];
            this.longtitude = _data["longtitude"];
            this.latitude = _data["latitude"];
            this.viewCount = _data["viewCount"];
            this.isApprove = _data["isApprove"];
            this.approveStatusName = _data["approveStatusName"];
            this.approveDate = _data["approveDate"] ? new Date(_data["approveDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["projectFeatures"])) {
                this.projectFeatures = [] as any;
                for (let item of _data["projectFeatures"])
                    this.projectFeatures!.push(ProjectFeatureModel.fromJS(item));
            }
            if (Array.isArray(_data["projectImages"])) {
                this.projectImages = [] as any;
                for (let item of _data["projectImages"])
                    this.projectImages!.push(ProjectImageModel.fromJS(item));
            }
            if (Array.isArray(_data["projectSellers"])) {
                this.projectSellers = [] as any;
                for (let item of _data["projectSellers"])
                    this.projectSellers!.push(ProjectSellerModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyTypeId"] = this.propertyTypeId;
        data["propertyTypeVi"] = this.propertyTypeVi;
        data["propertyTypeEn"] = this.propertyTypeEn;
        data["projectVi"] = this.projectVi;
        data["projectEn"] = this.projectEn;
        data["coverImage"] = this.coverImage;
        data["coverImageUrl"] = this.coverImageUrl;
        data["projectLogo"] = this.projectLogo;
        data["projectLogoUrl"] = this.projectLogoUrl;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["developer"] = this.developer;
        data["video"] = this.video;
        data["virtualTour"] = this.virtualTour;
        data["floorPlans"] = this.floorPlans;
        data["mapViewImage"] = this.mapViewImage;
        data["mapViewImageUrl"] = this.mapViewImageUrl;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["provinceCode"] = this.provinceCode;
        data["districtCode"] = this.districtCode;
        data["wardCode"] = this.wardCode;
        data["provinceName"] = this.provinceName;
        data["districtName"] = this.districtName;
        data["wardName"] = this.wardName;
        data["street"] = this.street;
        data["descriptions"] = this.descriptions;
        data["longtitude"] = this.longtitude;
        data["latitude"] = this.latitude;
        data["viewCount"] = this.viewCount;
        data["isApprove"] = this.isApprove;
        data["approveStatusName"] = this.approveStatusName;
        data["approveDate"] = this.approveDate ? this.approveDate.toISOString() : <any>undefined;
        if (Array.isArray(this.projectFeatures)) {
            data["projectFeatures"] = [];
            for (let item of this.projectFeatures)
                data["projectFeatures"].push(item.toJSON());
        }
        if (Array.isArray(this.projectImages)) {
            data["projectImages"] = [];
            for (let item of this.projectImages)
                data["projectImages"].push(item.toJSON());
        }
        if (Array.isArray(this.projectSellers)) {
            data["projectSellers"] = [];
            for (let item of this.projectSellers)
                data["projectSellers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IProjectModel extends IAuditableModel {
    id?: string;
    propertyTypeId?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
    projectVi?: string | undefined;
    projectEn?: string | undefined;
    coverImage?: string | undefined;
    coverImageUrl?: string | undefined;
    projectLogo?: string | undefined;
    projectLogoUrl?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    developer?: string | undefined;
    video?: string | undefined;
    virtualTour?: string | undefined;
    floorPlans?: string | undefined;
    mapViewImage?: string | undefined;
    mapViewImageUrl?: string | undefined;
    status?: ProjectStatus;
    statusName?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    provinceName?: string | undefined;
    districtName?: string | undefined;
    wardName?: string | undefined;
    street?: string | undefined;
    descriptions?: string | undefined;
    longtitude?: string | undefined;
    latitude?: string | undefined;
    viewCount?: number | undefined;
    isApprove?: ProjectApproveStatus;
    approveStatusName?: string | undefined;
    approveDate?: Date | undefined;
    projectFeatures?: ProjectFeatureModel[] | undefined;
    projectImages?: ProjectImageModel[] | undefined;
    projectSellers?: ProjectSellerModel[] | undefined;
}

export enum ProjectStatus {
    OpenForSale = 1,
    CommingSoon = 2,
    AlmostSoldOut = 3,
}

export enum ProjectApproveStatus {
    New = 1,
    Active = 2,
    InActive = 3,
    Lock = -1,
}

export class ProjectFeatureModel extends AuditableModel implements IProjectFeatureModel {
    id?: string;
    projectId?: string;
    projectFeatureId?: string | undefined;
    projectFeatureVi?: string | undefined;
    projectFeatureEn?: string | undefined;
    descriptions?: string | undefined;

    constructor(data?: IProjectFeatureModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.projectId = _data["projectId"];
            this.projectFeatureId = _data["projectFeatureId"];
            this.projectFeatureVi = _data["projectFeatureVi"];
            this.projectFeatureEn = _data["projectFeatureEn"];
            this.descriptions = _data["descriptions"];
        }
    }

    static fromJS(data: any): ProjectFeatureModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFeatureModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["projectFeatureId"] = this.projectFeatureId;
        data["projectFeatureVi"] = this.projectFeatureVi;
        data["projectFeatureEn"] = this.projectFeatureEn;
        data["descriptions"] = this.descriptions;
        super.toJSON(data);
        return data;
    }
}

export interface IProjectFeatureModel extends IAuditableModel {
    id?: string;
    projectId?: string;
    projectFeatureId?: string | undefined;
    projectFeatureVi?: string | undefined;
    projectFeatureEn?: string | undefined;
    descriptions?: string | undefined;
}

export class ProjectImageModel extends AuditableModel implements IProjectImageModel {
    id?: string;
    name?: string | undefined;
    imagesPath?: string | undefined;
    imagesPathUrl?: string | undefined;
    projectId?: string;

    constructor(data?: IProjectImageModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.imagesPath = _data["imagesPath"];
            this.imagesPathUrl = _data["imagesPathUrl"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): ProjectImageModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectImageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imagesPath"] = this.imagesPath;
        data["imagesPathUrl"] = this.imagesPathUrl;
        data["projectId"] = this.projectId;
        super.toJSON(data);
        return data;
    }
}

export interface IProjectImageModel extends IAuditableModel {
    id?: string;
    name?: string | undefined;
    imagesPath?: string | undefined;
    imagesPathUrl?: string | undefined;
    projectId?: string;
}

export class ProjectSellerModel extends AuditableModel implements IProjectSellerModel {
    id?: string;
    projectId?: string;
    userId?: string;
    avatar?: string | undefined;
    avatarUrl?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    agency?: string | undefined;
    propertyCount?: number | undefined;
    socialNetworkUsers?: SocialNetworkUserModel[] | undefined;

    constructor(data?: IProjectSellerModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.projectId = _data["projectId"];
            this.userId = _data["userId"];
            this.avatar = _data["avatar"];
            this.avatarUrl = _data["avatarUrl"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber1 = _data["phoneNumber1"];
            this.phoneNumber2 = _data["phoneNumber2"];
            this.phoneNumber3 = _data["phoneNumber3"];
            this.agency = _data["agency"];
            this.propertyCount = _data["propertyCount"];
            if (Array.isArray(_data["socialNetworkUsers"])) {
                this.socialNetworkUsers = [] as any;
                for (let item of _data["socialNetworkUsers"])
                    this.socialNetworkUsers!.push(SocialNetworkUserModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectSellerModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSellerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectId"] = this.projectId;
        data["userId"] = this.userId;
        data["avatar"] = this.avatar;
        data["avatarUrl"] = this.avatarUrl;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber1"] = this.phoneNumber1;
        data["phoneNumber2"] = this.phoneNumber2;
        data["phoneNumber3"] = this.phoneNumber3;
        data["agency"] = this.agency;
        data["propertyCount"] = this.propertyCount;
        if (Array.isArray(this.socialNetworkUsers)) {
            data["socialNetworkUsers"] = [];
            for (let item of this.socialNetworkUsers)
                data["socialNetworkUsers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IProjectSellerModel extends IAuditableModel {
    id?: string;
    projectId?: string;
    userId?: string;
    avatar?: string | undefined;
    avatarUrl?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    agency?: string | undefined;
    propertyCount?: number | undefined;
    socialNetworkUsers?: SocialNetworkUserModel[] | undefined;
}

export class UpdateProjectModel extends CreateProjectModel implements IUpdateProjectModel {
    status?: ProjectStatus;

    constructor(data?: IUpdateProjectModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateProjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProjectModel extends ICreateProjectModel {
    status?: ProjectStatus;
}

export class PaginatedListOfProjectModel implements IPaginatedListOfProjectModel {
    items?: ProjectModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProjectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProjectModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProjectModel {
    items?: ProjectModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PagingProjectModel extends PagingIndexModel implements IPagingProjectModel {

    constructor(data?: IPagingProjectModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PagingProjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingProjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPagingProjectModel extends IPagingIndexModel {
}

export class SearchProjectModel extends PagingIndexModel implements ISearchProjectModel {
    projectName?: string | undefined;
    status?: ProjectStatus | undefined;
    location?: string | undefined;
    propertyTypeId?: string | undefined;
    sortingModel?: SortingProjectModel | undefined;

    constructor(data?: ISearchProjectModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.projectName = _data["projectName"];
            this.status = _data["status"];
            this.location = _data["location"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.sortingModel = _data["sortingModel"] ? SortingProjectModel.fromJS(_data["sortingModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchProjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchProjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectName"] = this.projectName;
        data["status"] = this.status;
        data["location"] = this.location;
        data["propertyTypeId"] = this.propertyTypeId;
        data["sortingModel"] = this.sortingModel ? this.sortingModel.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISearchProjectModel extends IPagingIndexModel {
    projectName?: string | undefined;
    status?: ProjectStatus | undefined;
    location?: string | undefined;
    propertyTypeId?: string | undefined;
    sortingModel?: SortingProjectModel | undefined;
}

export class SortingProjectModel implements ISortingProjectModel {
    latest?: boolean | undefined;
    oldest?: boolean | undefined;
    mostView?: boolean | undefined;
    leastView?: boolean | undefined;

    constructor(data?: ISortingProjectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latest = _data["latest"];
            this.oldest = _data["oldest"];
            this.mostView = _data["mostView"];
            this.leastView = _data["leastView"];
        }
    }

    static fromJS(data: any): SortingProjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new SortingProjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latest"] = this.latest;
        data["oldest"] = this.oldest;
        data["mostView"] = this.mostView;
        data["leastView"] = this.leastView;
        return data;
    }
}

export interface ISortingProjectModel {
    latest?: boolean | undefined;
    oldest?: boolean | undefined;
    mostView?: boolean | undefined;
    leastView?: boolean | undefined;
}

export class AdministrativeByProjectModel implements IAdministrativeByProjectModel {
    code?: string | undefined;
    name?: string | undefined;
    nameWithType?: string | undefined;

    constructor(data?: IAdministrativeByProjectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.nameWithType = _data["nameWithType"];
        }
    }

    static fromJS(data: any): AdministrativeByProjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new AdministrativeByProjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["nameWithType"] = this.nameWithType;
        return data;
    }
}

export interface IAdministrativeByProjectModel {
    code?: string | undefined;
    name?: string | undefined;
    nameWithType?: string | undefined;
}

export class SuggestSearchProjectModel implements ISuggestSearchProjectModel {
    projectId?: string;
    titleVi?: string | undefined;
    titleEn?: string | undefined;

    constructor(data?: ISuggestSearchProjectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.titleVi = _data["titleVi"];
            this.titleEn = _data["titleEn"];
        }
    }

    static fromJS(data: any): SuggestSearchProjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestSearchProjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["titleVi"] = this.titleVi;
        data["titleEn"] = this.titleEn;
        return data;
    }
}

export interface ISuggestSearchProjectModel {
    projectId?: string;
    titleVi?: string | undefined;
    titleEn?: string | undefined;
}

export class SearchProjectForAdminModel extends PagingIndexModel implements ISearchProjectForAdminModel {
    projectName?: string | undefined;
    isApprove?: ProjectApproveStatus | undefined;
    status?: ProjectStatus | undefined;
    propertyTypeId?: string | undefined;
    sortingModel?: SortingProjectModel | undefined;

    constructor(data?: ISearchProjectForAdminModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.projectName = _data["projectName"];
            this.isApprove = _data["isApprove"];
            this.status = _data["status"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.sortingModel = _data["sortingModel"] ? SortingProjectModel.fromJS(_data["sortingModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchProjectForAdminModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchProjectForAdminModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectName"] = this.projectName;
        data["isApprove"] = this.isApprove;
        data["status"] = this.status;
        data["propertyTypeId"] = this.propertyTypeId;
        data["sortingModel"] = this.sortingModel ? this.sortingModel.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISearchProjectForAdminModel extends IPagingIndexModel {
    projectName?: string | undefined;
    isApprove?: ProjectApproveStatus | undefined;
    status?: ProjectStatus | undefined;
    propertyTypeId?: string | undefined;
    sortingModel?: SortingProjectModel | undefined;
}

export class CreatePropertyModel implements ICreatePropertyModel {
    transactionTypeId?: string | undefined;
    propertyTypeId?: string | undefined;
    coverImage?: string | undefined;
    videoLink?: string | undefined;
    virtualVideoLink?: string | undefined;
    address?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    street?: string | undefined;
    projectId?: string;
    propertyAddressVi?: string | undefined;
    propertyAddressEn?: string | undefined;
    title?: string | undefined;
    descriptions?: string | undefined;
    supplierId?: string;
    isShowSupplier?: boolean | undefined;
    lotSize?: number | undefined;
    price?: number | undefined;
    currencyId?: string | undefined;
    bedroomId?: string | undefined;
    bathroomId?: string | undefined;
    floorsNumber?: number | undefined;
    totalBuildingFloors?: number | undefined;
    yearCompleted?: Date | undefined;
    longitude?: string | undefined;
    latitude?: string | undefined;
    isSubmit?: boolean;
    propertyImages?: CreatePropertyImageModel[] | undefined;
    propertyViews?: CreatePropertyViewModel[] | undefined;
    propertyAmenitiesNearbys?: CreatePropertyAmenitiesNearbyModel[] | undefined;

    constructor(data?: ICreatePropertyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionTypeId = _data["transactionTypeId"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.coverImage = _data["coverImage"];
            this.videoLink = _data["videoLink"];
            this.virtualVideoLink = _data["virtualVideoLink"];
            this.address = _data["address"];
            this.provinceCode = _data["provinceCode"];
            this.districtCode = _data["districtCode"];
            this.wardCode = _data["wardCode"];
            this.street = _data["street"];
            this.projectId = _data["projectId"];
            this.propertyAddressVi = _data["propertyAddressVi"];
            this.propertyAddressEn = _data["propertyAddressEn"];
            this.title = _data["title"];
            this.descriptions = _data["descriptions"];
            this.supplierId = _data["supplierId"];
            this.isShowSupplier = _data["isShowSupplier"];
            this.lotSize = _data["lotSize"];
            this.price = _data["price"];
            this.currencyId = _data["currencyId"];
            this.bedroomId = _data["bedroomId"];
            this.bathroomId = _data["bathroomId"];
            this.floorsNumber = _data["floorsNumber"];
            this.totalBuildingFloors = _data["totalBuildingFloors"];
            this.yearCompleted = _data["yearCompleted"] ? new Date(_data["yearCompleted"].toString()) : <any>undefined;
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.isSubmit = _data["isSubmit"];
            if (Array.isArray(_data["propertyImages"])) {
                this.propertyImages = [] as any;
                for (let item of _data["propertyImages"])
                    this.propertyImages!.push(CreatePropertyImageModel.fromJS(item));
            }
            if (Array.isArray(_data["propertyViews"])) {
                this.propertyViews = [] as any;
                for (let item of _data["propertyViews"])
                    this.propertyViews!.push(CreatePropertyViewModel.fromJS(item));
            }
            if (Array.isArray(_data["propertyAmenitiesNearbys"])) {
                this.propertyAmenitiesNearbys = [] as any;
                for (let item of _data["propertyAmenitiesNearbys"])
                    this.propertyAmenitiesNearbys!.push(CreatePropertyAmenitiesNearbyModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionTypeId"] = this.transactionTypeId;
        data["propertyTypeId"] = this.propertyTypeId;
        data["coverImage"] = this.coverImage;
        data["videoLink"] = this.videoLink;
        data["virtualVideoLink"] = this.virtualVideoLink;
        data["address"] = this.address;
        data["provinceCode"] = this.provinceCode;
        data["districtCode"] = this.districtCode;
        data["wardCode"] = this.wardCode;
        data["street"] = this.street;
        data["projectId"] = this.projectId;
        data["propertyAddressVi"] = this.propertyAddressVi;
        data["propertyAddressEn"] = this.propertyAddressEn;
        data["title"] = this.title;
        data["descriptions"] = this.descriptions;
        data["supplierId"] = this.supplierId;
        data["isShowSupplier"] = this.isShowSupplier;
        data["lotSize"] = this.lotSize;
        data["price"] = this.price;
        data["currencyId"] = this.currencyId;
        data["bedroomId"] = this.bedroomId;
        data["bathroomId"] = this.bathroomId;
        data["floorsNumber"] = this.floorsNumber;
        data["totalBuildingFloors"] = this.totalBuildingFloors;
        data["yearCompleted"] = this.yearCompleted ? this.yearCompleted.toISOString() : <any>undefined;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["isSubmit"] = this.isSubmit;
        if (Array.isArray(this.propertyImages)) {
            data["propertyImages"] = [];
            for (let item of this.propertyImages)
                data["propertyImages"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyViews)) {
            data["propertyViews"] = [];
            for (let item of this.propertyViews)
                data["propertyViews"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyAmenitiesNearbys)) {
            data["propertyAmenitiesNearbys"] = [];
            for (let item of this.propertyAmenitiesNearbys)
                data["propertyAmenitiesNearbys"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreatePropertyModel {
    transactionTypeId?: string | undefined;
    propertyTypeId?: string | undefined;
    coverImage?: string | undefined;
    videoLink?: string | undefined;
    virtualVideoLink?: string | undefined;
    address?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    street?: string | undefined;
    projectId?: string;
    propertyAddressVi?: string | undefined;
    propertyAddressEn?: string | undefined;
    title?: string | undefined;
    descriptions?: string | undefined;
    supplierId?: string;
    isShowSupplier?: boolean | undefined;
    lotSize?: number | undefined;
    price?: number | undefined;
    currencyId?: string | undefined;
    bedroomId?: string | undefined;
    bathroomId?: string | undefined;
    floorsNumber?: number | undefined;
    totalBuildingFloors?: number | undefined;
    yearCompleted?: Date | undefined;
    longitude?: string | undefined;
    latitude?: string | undefined;
    isSubmit?: boolean;
    propertyImages?: CreatePropertyImageModel[] | undefined;
    propertyViews?: CreatePropertyViewModel[] | undefined;
    propertyAmenitiesNearbys?: CreatePropertyAmenitiesNearbyModel[] | undefined;
}

export class CreatePropertyImageModel implements ICreatePropertyImageModel {
    name?: string | undefined;
    imagesPath?: string | undefined;
    notes?: string | undefined;

    constructor(data?: ICreatePropertyImageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.imagesPath = _data["imagesPath"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CreatePropertyImageModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyImageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["imagesPath"] = this.imagesPath;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICreatePropertyImageModel {
    name?: string | undefined;
    imagesPath?: string | undefined;
    notes?: string | undefined;
}

export class CreatePropertyViewModel implements ICreatePropertyViewModel {
    viewId?: string | undefined;

    constructor(data?: ICreatePropertyViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.viewId = _data["viewId"];
        }
    }

    static fromJS(data: any): CreatePropertyViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viewId"] = this.viewId;
        return data;
    }
}

export interface ICreatePropertyViewModel {
    viewId?: string | undefined;
}

export class CreatePropertyAmenitiesNearbyModel implements ICreatePropertyAmenitiesNearbyModel {
    amenitiesNearbyId?: string | undefined;

    constructor(data?: ICreatePropertyAmenitiesNearbyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amenitiesNearbyId = _data["amenitiesNearbyId"];
        }
    }

    static fromJS(data: any): CreatePropertyAmenitiesNearbyModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyAmenitiesNearbyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amenitiesNearbyId"] = this.amenitiesNearbyId;
        return data;
    }
}

export interface ICreatePropertyAmenitiesNearbyModel {
    amenitiesNearbyId?: string | undefined;
}

export class ListPropertyModel extends AuditableModel implements IListPropertyModel {
    id?: string;
    title?: string | undefined;
    propertyNumber?: string | undefined;
    coverImage?: string | undefined;
    coverImageUrl?: string | undefined;
    propertyAddressVi?: string | undefined;
    propertyAddressEn?: string | undefined;
    price?: number | undefined;
    currencyId?: string | undefined;
    currencyName?: string | undefined;
    currencyNotation?: string | undefined;
    transactionTypeId?: string | undefined;
    transactionTypeVi?: string | undefined;
    transactionTypeEn?: string | undefined;
    bedroomId?: string | undefined;
    bedroomVi?: string | undefined;
    bedroomEn?: string | undefined;
    bathroomId?: string | undefined;
    bathroomVi?: string | undefined;
    bathroomEn?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    provinceName?: string | undefined;
    districtName?: string | undefined;
    wardName?: string | undefined;
    coordinatesProvince?: string | undefined;
    coordinatesDistrict?: string | undefined;
    coordinatesWard?: string | undefined;
    location?: string | undefined;
    lotSize?: number | undefined;
    longitude?: string | undefined;
    latitude?: string | undefined;
    isApprove?: PropertyApproveStatus;
    approveStatusName?: string | undefined;
    timeForPostId?: string | undefined;
    timeForPostValue?: number | undefined;
    timeForPostName?: string | undefined;
    timeRemain?: number | undefined;
    approveDate?: Date | undefined;
    expiredDate?: Date | undefined;
    isTemp?: boolean;
    viewCount?: number;

    constructor(data?: IListPropertyModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.propertyNumber = _data["propertyNumber"];
            this.coverImage = _data["coverImage"];
            this.coverImageUrl = _data["coverImageUrl"];
            this.propertyAddressVi = _data["propertyAddressVi"];
            this.propertyAddressEn = _data["propertyAddressEn"];
            this.price = _data["price"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.currencyNotation = _data["currencyNotation"];
            this.transactionTypeId = _data["transactionTypeId"];
            this.transactionTypeVi = _data["transactionTypeVi"];
            this.transactionTypeEn = _data["transactionTypeEn"];
            this.bedroomId = _data["bedroomId"];
            this.bedroomVi = _data["bedroomVi"];
            this.bedroomEn = _data["bedroomEn"];
            this.bathroomId = _data["bathroomId"];
            this.bathroomVi = _data["bathroomVi"];
            this.bathroomEn = _data["bathroomEn"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.propertyTypeVi = _data["propertyTypeVi"];
            this.propertyTypeEn = _data["propertyTypeEn"];
            this.provinceCode = _data["provinceCode"];
            this.districtCode = _data["districtCode"];
            this.wardCode = _data["wardCode"];
            this.provinceName = _data["provinceName"];
            this.districtName = _data["districtName"];
            this.wardName = _data["wardName"];
            this.coordinatesProvince = _data["coordinatesProvince"];
            this.coordinatesDistrict = _data["coordinatesDistrict"];
            this.coordinatesWard = _data["coordinatesWard"];
            this.location = _data["location"];
            this.lotSize = _data["lotSize"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.isApprove = _data["isApprove"];
            this.approveStatusName = _data["approveStatusName"];
            this.timeForPostId = _data["timeForPostId"];
            this.timeForPostValue = _data["timeForPostValue"];
            this.timeForPostName = _data["timeForPostName"];
            this.timeRemain = _data["timeRemain"];
            this.approveDate = _data["approveDate"] ? new Date(_data["approveDate"].toString()) : <any>undefined;
            this.expiredDate = _data["expiredDate"] ? new Date(_data["expiredDate"].toString()) : <any>undefined;
            this.isTemp = _data["isTemp"];
            this.viewCount = _data["viewCount"];
        }
    }

    static fromJS(data: any): ListPropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListPropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["propertyNumber"] = this.propertyNumber;
        data["coverImage"] = this.coverImage;
        data["coverImageUrl"] = this.coverImageUrl;
        data["propertyAddressVi"] = this.propertyAddressVi;
        data["propertyAddressEn"] = this.propertyAddressEn;
        data["price"] = this.price;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["currencyNotation"] = this.currencyNotation;
        data["transactionTypeId"] = this.transactionTypeId;
        data["transactionTypeVi"] = this.transactionTypeVi;
        data["transactionTypeEn"] = this.transactionTypeEn;
        data["bedroomId"] = this.bedroomId;
        data["bedroomVi"] = this.bedroomVi;
        data["bedroomEn"] = this.bedroomEn;
        data["bathroomId"] = this.bathroomId;
        data["bathroomVi"] = this.bathroomVi;
        data["bathroomEn"] = this.bathroomEn;
        data["propertyTypeId"] = this.propertyTypeId;
        data["propertyTypeVi"] = this.propertyTypeVi;
        data["propertyTypeEn"] = this.propertyTypeEn;
        data["provinceCode"] = this.provinceCode;
        data["districtCode"] = this.districtCode;
        data["wardCode"] = this.wardCode;
        data["provinceName"] = this.provinceName;
        data["districtName"] = this.districtName;
        data["wardName"] = this.wardName;
        data["coordinatesProvince"] = this.coordinatesProvince;
        data["coordinatesDistrict"] = this.coordinatesDistrict;
        data["coordinatesWard"] = this.coordinatesWard;
        data["location"] = this.location;
        data["lotSize"] = this.lotSize;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["isApprove"] = this.isApprove;
        data["approveStatusName"] = this.approveStatusName;
        data["timeForPostId"] = this.timeForPostId;
        data["timeForPostValue"] = this.timeForPostValue;
        data["timeForPostName"] = this.timeForPostName;
        data["timeRemain"] = this.timeRemain;
        data["approveDate"] = this.approveDate ? this.approveDate.toISOString() : <any>undefined;
        data["expiredDate"] = this.expiredDate ? this.expiredDate.toISOString() : <any>undefined;
        data["isTemp"] = this.isTemp;
        data["viewCount"] = this.viewCount;
        super.toJSON(data);
        return data;
    }
}

export interface IListPropertyModel extends IAuditableModel {
    id?: string;
    title?: string | undefined;
    propertyNumber?: string | undefined;
    coverImage?: string | undefined;
    coverImageUrl?: string | undefined;
    propertyAddressVi?: string | undefined;
    propertyAddressEn?: string | undefined;
    price?: number | undefined;
    currencyId?: string | undefined;
    currencyName?: string | undefined;
    currencyNotation?: string | undefined;
    transactionTypeId?: string | undefined;
    transactionTypeVi?: string | undefined;
    transactionTypeEn?: string | undefined;
    bedroomId?: string | undefined;
    bedroomVi?: string | undefined;
    bedroomEn?: string | undefined;
    bathroomId?: string | undefined;
    bathroomVi?: string | undefined;
    bathroomEn?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    provinceName?: string | undefined;
    districtName?: string | undefined;
    wardName?: string | undefined;
    coordinatesProvince?: string | undefined;
    coordinatesDistrict?: string | undefined;
    coordinatesWard?: string | undefined;
    location?: string | undefined;
    lotSize?: number | undefined;
    longitude?: string | undefined;
    latitude?: string | undefined;
    isApprove?: PropertyApproveStatus;
    approveStatusName?: string | undefined;
    timeForPostId?: string | undefined;
    timeForPostValue?: number | undefined;
    timeForPostName?: string | undefined;
    timeRemain?: number | undefined;
    approveDate?: Date | undefined;
    expiredDate?: Date | undefined;
    isTemp?: boolean;
    viewCount?: number;
}

export enum PropertyApproveStatus {
    New = 1,
    Active = 2,
    InActive = 3,
    Expired = 4,
    Draft = 5,
    Lock = -1,
}

export class FilterPropertyByUserModel implements IFilterPropertyByUserModel {
    transactionTypeId?: string | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    listStatus?: PropertyApproveStatus[] | undefined;

    constructor(data?: IFilterPropertyByUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionTypeId = _data["transactionTypeId"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["listStatus"])) {
                this.listStatus = [] as any;
                for (let item of _data["listStatus"])
                    this.listStatus!.push(item);
            }
        }
    }

    static fromJS(data: any): FilterPropertyByUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilterPropertyByUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionTypeId"] = this.transactionTypeId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        if (Array.isArray(this.listStatus)) {
            data["listStatus"] = [];
            for (let item of this.listStatus)
                data["listStatus"].push(item);
        }
        return data;
    }
}

export interface IFilterPropertyByUserModel {
    transactionTypeId?: string | undefined;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    listStatus?: PropertyApproveStatus[] | undefined;
}

export class BasicPropertyModel implements IBasicPropertyModel {
    id?: string;
    longitude?: string | undefined;
    latitude?: string | undefined;

    constructor(data?: IBasicPropertyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): BasicPropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new BasicPropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data;
    }
}

export interface IBasicPropertyModel {
    id?: string;
    longitude?: string | undefined;
    latitude?: string | undefined;
}

export class PropertyModel extends AuditableModel implements IPropertyModel {
    id?: string;
    propertyNumber?: string | undefined;
    transactionTypeId?: string | undefined;
    transactionTypeVi?: string | undefined;
    transactionTypeEn?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
    coverImage?: string | undefined;
    coverImageUrl?: string | undefined;
    videoLink?: string | undefined;
    virtualVideoLink?: string | undefined;
    address?: string | undefined;
    provinceCode?: string | undefined;
    provinceName?: string | undefined;
    districtCode?: string | undefined;
    districtName?: string | undefined;
    wardCode?: string | undefined;
    wardName?: string | undefined;
    street?: string | undefined;
    projectId?: string;
    projectVi?: string | undefined;
    projectEn?: string | undefined;
    propertyAddressVi?: string | undefined;
    propertyAddressEn?: string | undefined;
    title?: string | undefined;
    descriptions?: string | undefined;
    lotSize?: number | undefined;
    price?: number | undefined;
    currencyId?: string | undefined;
    currencyName?: string | undefined;
    currencyNotation?: string | undefined;
    bedroomId?: string | undefined;
    bedroomVi?: string | undefined;
    bedroomEn?: string | undefined;
    bathroomId?: string | undefined;
    bathroomVi?: string | undefined;
    bathroomEn?: string | undefined;
    floorsNumber?: number | undefined;
    totalBuildingFloors?: number | undefined;
    yearCompleted?: Date | undefined;
    longitude?: string | undefined;
    latitude?: string | undefined;
    timeForPostId?: string | undefined;
    timeForPostValue?: number | undefined;
    timeForPostName?: string | undefined;
    timeRemain?: number | undefined;
    isApprove?: PropertyApproveStatus;
    approveStatusName?: string | undefined;
    approveDate?: Date | undefined;
    isTemp?: boolean;
    viewCount?: number;
    supplierId?: string;
    isShowSupplier?: boolean | undefined;
    supplierAvatar?: string | undefined;
    supplierFirstName?: string | undefined;
    supplierLastName?: string | undefined;
    supplierEmail?: string | undefined;
    suppierPhoneNumber1?: string | undefined;
    suppierPhoneNumber2?: string | undefined;
    propertyImages?: PropertyImageModel[] | undefined;
    propertyViews?: PropertyViewModel[] | undefined;
    propertyAmenitiesNearbys?: PropertyAmenitiesNearbyModel[] | undefined;
    propertySellers?: PropertySellerModel[] | undefined;

    constructor(data?: IPropertyModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.propertyNumber = _data["propertyNumber"];
            this.transactionTypeId = _data["transactionTypeId"];
            this.transactionTypeVi = _data["transactionTypeVi"];
            this.transactionTypeEn = _data["transactionTypeEn"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.propertyTypeVi = _data["propertyTypeVi"];
            this.propertyTypeEn = _data["propertyTypeEn"];
            this.coverImage = _data["coverImage"];
            this.coverImageUrl = _data["coverImageUrl"];
            this.videoLink = _data["videoLink"];
            this.virtualVideoLink = _data["virtualVideoLink"];
            this.address = _data["address"];
            this.provinceCode = _data["provinceCode"];
            this.provinceName = _data["provinceName"];
            this.districtCode = _data["districtCode"];
            this.districtName = _data["districtName"];
            this.wardCode = _data["wardCode"];
            this.wardName = _data["wardName"];
            this.street = _data["street"];
            this.projectId = _data["projectId"];
            this.projectVi = _data["projectVi"];
            this.projectEn = _data["projectEn"];
            this.propertyAddressVi = _data["propertyAddressVi"];
            this.propertyAddressEn = _data["propertyAddressEn"];
            this.title = _data["title"];
            this.descriptions = _data["descriptions"];
            this.lotSize = _data["lotSize"];
            this.price = _data["price"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.currencyNotation = _data["currencyNotation"];
            this.bedroomId = _data["bedroomId"];
            this.bedroomVi = _data["bedroomVi"];
            this.bedroomEn = _data["bedroomEn"];
            this.bathroomId = _data["bathroomId"];
            this.bathroomVi = _data["bathroomVi"];
            this.bathroomEn = _data["bathroomEn"];
            this.floorsNumber = _data["floorsNumber"];
            this.totalBuildingFloors = _data["totalBuildingFloors"];
            this.yearCompleted = _data["yearCompleted"] ? new Date(_data["yearCompleted"].toString()) : <any>undefined;
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.timeForPostId = _data["timeForPostId"];
            this.timeForPostValue = _data["timeForPostValue"];
            this.timeForPostName = _data["timeForPostName"];
            this.timeRemain = _data["timeRemain"];
            this.isApprove = _data["isApprove"];
            this.approveStatusName = _data["approveStatusName"];
            this.approveDate = _data["approveDate"] ? new Date(_data["approveDate"].toString()) : <any>undefined;
            this.isTemp = _data["isTemp"];
            this.viewCount = _data["viewCount"];
            this.supplierId = _data["supplierId"];
            this.isShowSupplier = _data["isShowSupplier"];
            this.supplierAvatar = _data["supplierAvatar"];
            this.supplierFirstName = _data["supplierFirstName"];
            this.supplierLastName = _data["supplierLastName"];
            this.supplierEmail = _data["supplierEmail"];
            this.suppierPhoneNumber1 = _data["suppierPhoneNumber1"];
            this.suppierPhoneNumber2 = _data["suppierPhoneNumber2"];
            if (Array.isArray(_data["propertyImages"])) {
                this.propertyImages = [] as any;
                for (let item of _data["propertyImages"])
                    this.propertyImages!.push(PropertyImageModel.fromJS(item));
            }
            if (Array.isArray(_data["propertyViews"])) {
                this.propertyViews = [] as any;
                for (let item of _data["propertyViews"])
                    this.propertyViews!.push(PropertyViewModel.fromJS(item));
            }
            if (Array.isArray(_data["propertyAmenitiesNearbys"])) {
                this.propertyAmenitiesNearbys = [] as any;
                for (let item of _data["propertyAmenitiesNearbys"])
                    this.propertyAmenitiesNearbys!.push(PropertyAmenitiesNearbyModel.fromJS(item));
            }
            if (Array.isArray(_data["propertySellers"])) {
                this.propertySellers = [] as any;
                for (let item of _data["propertySellers"])
                    this.propertySellers!.push(PropertySellerModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyNumber"] = this.propertyNumber;
        data["transactionTypeId"] = this.transactionTypeId;
        data["transactionTypeVi"] = this.transactionTypeVi;
        data["transactionTypeEn"] = this.transactionTypeEn;
        data["propertyTypeId"] = this.propertyTypeId;
        data["propertyTypeVi"] = this.propertyTypeVi;
        data["propertyTypeEn"] = this.propertyTypeEn;
        data["coverImage"] = this.coverImage;
        data["coverImageUrl"] = this.coverImageUrl;
        data["videoLink"] = this.videoLink;
        data["virtualVideoLink"] = this.virtualVideoLink;
        data["address"] = this.address;
        data["provinceCode"] = this.provinceCode;
        data["provinceName"] = this.provinceName;
        data["districtCode"] = this.districtCode;
        data["districtName"] = this.districtName;
        data["wardCode"] = this.wardCode;
        data["wardName"] = this.wardName;
        data["street"] = this.street;
        data["projectId"] = this.projectId;
        data["projectVi"] = this.projectVi;
        data["projectEn"] = this.projectEn;
        data["propertyAddressVi"] = this.propertyAddressVi;
        data["propertyAddressEn"] = this.propertyAddressEn;
        data["title"] = this.title;
        data["descriptions"] = this.descriptions;
        data["lotSize"] = this.lotSize;
        data["price"] = this.price;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["currencyNotation"] = this.currencyNotation;
        data["bedroomId"] = this.bedroomId;
        data["bedroomVi"] = this.bedroomVi;
        data["bedroomEn"] = this.bedroomEn;
        data["bathroomId"] = this.bathroomId;
        data["bathroomVi"] = this.bathroomVi;
        data["bathroomEn"] = this.bathroomEn;
        data["floorsNumber"] = this.floorsNumber;
        data["totalBuildingFloors"] = this.totalBuildingFloors;
        data["yearCompleted"] = this.yearCompleted ? this.yearCompleted.toISOString() : <any>undefined;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["timeForPostId"] = this.timeForPostId;
        data["timeForPostValue"] = this.timeForPostValue;
        data["timeForPostName"] = this.timeForPostName;
        data["timeRemain"] = this.timeRemain;
        data["isApprove"] = this.isApprove;
        data["approveStatusName"] = this.approveStatusName;
        data["approveDate"] = this.approveDate ? this.approveDate.toISOString() : <any>undefined;
        data["isTemp"] = this.isTemp;
        data["viewCount"] = this.viewCount;
        data["supplierId"] = this.supplierId;
        data["isShowSupplier"] = this.isShowSupplier;
        data["supplierAvatar"] = this.supplierAvatar;
        data["supplierFirstName"] = this.supplierFirstName;
        data["supplierLastName"] = this.supplierLastName;
        data["supplierEmail"] = this.supplierEmail;
        data["suppierPhoneNumber1"] = this.suppierPhoneNumber1;
        data["suppierPhoneNumber2"] = this.suppierPhoneNumber2;
        if (Array.isArray(this.propertyImages)) {
            data["propertyImages"] = [];
            for (let item of this.propertyImages)
                data["propertyImages"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyViews)) {
            data["propertyViews"] = [];
            for (let item of this.propertyViews)
                data["propertyViews"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyAmenitiesNearbys)) {
            data["propertyAmenitiesNearbys"] = [];
            for (let item of this.propertyAmenitiesNearbys)
                data["propertyAmenitiesNearbys"].push(item.toJSON());
        }
        if (Array.isArray(this.propertySellers)) {
            data["propertySellers"] = [];
            for (let item of this.propertySellers)
                data["propertySellers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPropertyModel extends IAuditableModel {
    id?: string;
    propertyNumber?: string | undefined;
    transactionTypeId?: string | undefined;
    transactionTypeVi?: string | undefined;
    transactionTypeEn?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
    coverImage?: string | undefined;
    coverImageUrl?: string | undefined;
    videoLink?: string | undefined;
    virtualVideoLink?: string | undefined;
    address?: string | undefined;
    provinceCode?: string | undefined;
    provinceName?: string | undefined;
    districtCode?: string | undefined;
    districtName?: string | undefined;
    wardCode?: string | undefined;
    wardName?: string | undefined;
    street?: string | undefined;
    projectId?: string;
    projectVi?: string | undefined;
    projectEn?: string | undefined;
    propertyAddressVi?: string | undefined;
    propertyAddressEn?: string | undefined;
    title?: string | undefined;
    descriptions?: string | undefined;
    lotSize?: number | undefined;
    price?: number | undefined;
    currencyId?: string | undefined;
    currencyName?: string | undefined;
    currencyNotation?: string | undefined;
    bedroomId?: string | undefined;
    bedroomVi?: string | undefined;
    bedroomEn?: string | undefined;
    bathroomId?: string | undefined;
    bathroomVi?: string | undefined;
    bathroomEn?: string | undefined;
    floorsNumber?: number | undefined;
    totalBuildingFloors?: number | undefined;
    yearCompleted?: Date | undefined;
    longitude?: string | undefined;
    latitude?: string | undefined;
    timeForPostId?: string | undefined;
    timeForPostValue?: number | undefined;
    timeForPostName?: string | undefined;
    timeRemain?: number | undefined;
    isApprove?: PropertyApproveStatus;
    approveStatusName?: string | undefined;
    approveDate?: Date | undefined;
    isTemp?: boolean;
    viewCount?: number;
    supplierId?: string;
    isShowSupplier?: boolean | undefined;
    supplierAvatar?: string | undefined;
    supplierFirstName?: string | undefined;
    supplierLastName?: string | undefined;
    supplierEmail?: string | undefined;
    suppierPhoneNumber1?: string | undefined;
    suppierPhoneNumber2?: string | undefined;
    propertyImages?: PropertyImageModel[] | undefined;
    propertyViews?: PropertyViewModel[] | undefined;
    propertyAmenitiesNearbys?: PropertyAmenitiesNearbyModel[] | undefined;
    propertySellers?: PropertySellerModel[] | undefined;
}

export class PropertyImageModel implements IPropertyImageModel {
    id?: string;
    name?: string | undefined;
    imagesPath?: string | undefined;
    propertyId?: string;
    notes?: string | undefined;
    imagesUrl?: string | undefined;

    constructor(data?: IPropertyImageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.imagesPath = _data["imagesPath"];
            this.propertyId = _data["propertyId"];
            this.notes = _data["notes"];
            this.imagesUrl = _data["imagesUrl"];
        }
    }

    static fromJS(data: any): PropertyImageModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyImageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imagesPath"] = this.imagesPath;
        data["propertyId"] = this.propertyId;
        data["notes"] = this.notes;
        data["imagesUrl"] = this.imagesUrl;
        return data;
    }
}

export interface IPropertyImageModel {
    id?: string;
    name?: string | undefined;
    imagesPath?: string | undefined;
    propertyId?: string;
    notes?: string | undefined;
    imagesUrl?: string | undefined;
}

export class PropertyViewModel extends AuditableModel implements IPropertyViewModel {
    id?: string;
    propertyId?: string;
    viewId?: string | undefined;
    viewVi?: string | undefined;
    viewEn?: string | undefined;
    viewDescriptions?: string | undefined;

    constructor(data?: IPropertyViewModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.propertyId = _data["propertyId"];
            this.viewId = _data["viewId"];
            this.viewVi = _data["viewVi"];
            this.viewEn = _data["viewEn"];
            this.viewDescriptions = _data["viewDescriptions"];
        }
    }

    static fromJS(data: any): PropertyViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyId"] = this.propertyId;
        data["viewId"] = this.viewId;
        data["viewVi"] = this.viewVi;
        data["viewEn"] = this.viewEn;
        data["viewDescriptions"] = this.viewDescriptions;
        super.toJSON(data);
        return data;
    }
}

export interface IPropertyViewModel extends IAuditableModel {
    id?: string;
    propertyId?: string;
    viewId?: string | undefined;
    viewVi?: string | undefined;
    viewEn?: string | undefined;
    viewDescriptions?: string | undefined;
}

export class PropertyAmenitiesNearbyModel extends AuditableModel implements IPropertyAmenitiesNearbyModel {
    id?: string;
    propertyId?: string;
    amenitiesNearbyId?: string | undefined;
    amenitiesNearbyVi?: string | undefined;
    amenitiesNearbyEn?: string | undefined;
    descriptions?: string | undefined;

    constructor(data?: IPropertyAmenitiesNearbyModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.propertyId = _data["propertyId"];
            this.amenitiesNearbyId = _data["amenitiesNearbyId"];
            this.amenitiesNearbyVi = _data["amenitiesNearbyVi"];
            this.amenitiesNearbyEn = _data["amenitiesNearbyEn"];
            this.descriptions = _data["descriptions"];
        }
    }

    static fromJS(data: any): PropertyAmenitiesNearbyModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyAmenitiesNearbyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyId"] = this.propertyId;
        data["amenitiesNearbyId"] = this.amenitiesNearbyId;
        data["amenitiesNearbyVi"] = this.amenitiesNearbyVi;
        data["amenitiesNearbyEn"] = this.amenitiesNearbyEn;
        data["descriptions"] = this.descriptions;
        super.toJSON(data);
        return data;
    }
}

export interface IPropertyAmenitiesNearbyModel extends IAuditableModel {
    id?: string;
    propertyId?: string;
    amenitiesNearbyId?: string | undefined;
    amenitiesNearbyVi?: string | undefined;
    amenitiesNearbyEn?: string | undefined;
    descriptions?: string | undefined;
}

export class PropertySellerModel extends AuditableModel implements IPropertySellerModel {
    id?: string;
    propertyId?: string;
    userId?: string;
    avatar?: string | undefined;
    avatarUrl?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    email?: string | undefined;
    agency?: string | undefined;
    propertyCount?: number | undefined;
    socialNetworkUsers?: SocialNetworkUserModel[] | undefined;

    constructor(data?: IPropertySellerModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.propertyId = _data["propertyId"];
            this.userId = _data["userId"];
            this.avatar = _data["avatar"];
            this.avatarUrl = _data["avatarUrl"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber1 = _data["phoneNumber1"];
            this.phoneNumber2 = _data["phoneNumber2"];
            this.phoneNumber3 = _data["phoneNumber3"];
            this.email = _data["email"];
            this.agency = _data["agency"];
            this.propertyCount = _data["propertyCount"];
            if (Array.isArray(_data["socialNetworkUsers"])) {
                this.socialNetworkUsers = [] as any;
                for (let item of _data["socialNetworkUsers"])
                    this.socialNetworkUsers!.push(SocialNetworkUserModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PropertySellerModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertySellerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyId"] = this.propertyId;
        data["userId"] = this.userId;
        data["avatar"] = this.avatar;
        data["avatarUrl"] = this.avatarUrl;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber1"] = this.phoneNumber1;
        data["phoneNumber2"] = this.phoneNumber2;
        data["phoneNumber3"] = this.phoneNumber3;
        data["email"] = this.email;
        data["agency"] = this.agency;
        data["propertyCount"] = this.propertyCount;
        if (Array.isArray(this.socialNetworkUsers)) {
            data["socialNetworkUsers"] = [];
            for (let item of this.socialNetworkUsers)
                data["socialNetworkUsers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPropertySellerModel extends IAuditableModel {
    id?: string;
    propertyId?: string;
    userId?: string;
    avatar?: string | undefined;
    avatarUrl?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    email?: string | undefined;
    agency?: string | undefined;
    propertyCount?: number | undefined;
    socialNetworkUsers?: SocialNetworkUserModel[] | undefined;
}

export class UpdatePropertyModel extends CreatePropertyModel implements IUpdatePropertyModel {
    propertySellers?: CreatePropertySellerModel[] | undefined;
    propertyMeetingNote?: CreatePropertyMeetingNoteModel | undefined;

    constructor(data?: IUpdatePropertyModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["propertySellers"])) {
                this.propertySellers = [] as any;
                for (let item of _data["propertySellers"])
                    this.propertySellers!.push(CreatePropertySellerModel.fromJS(item));
            }
            this.propertyMeetingNote = _data["propertyMeetingNote"] ? CreatePropertyMeetingNoteModel.fromJS(_data["propertyMeetingNote"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdatePropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.propertySellers)) {
            data["propertySellers"] = [];
            for (let item of this.propertySellers)
                data["propertySellers"].push(item.toJSON());
        }
        data["propertyMeetingNote"] = this.propertyMeetingNote ? this.propertyMeetingNote.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdatePropertyModel extends ICreatePropertyModel {
    propertySellers?: CreatePropertySellerModel[] | undefined;
    propertyMeetingNote?: CreatePropertyMeetingNoteModel | undefined;
}

export class CreatePropertySellerModel implements ICreatePropertySellerModel {
    userId?: string;

    constructor(data?: ICreatePropertySellerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CreatePropertySellerModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertySellerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface ICreatePropertySellerModel {
    userId?: string;
}

export class CreatePropertyMeetingNoteModel implements ICreatePropertyMeetingNoteModel {
    meetingNoteTitle?: string | undefined;
    meetingNoteContent?: string | undefined;

    constructor(data?: ICreatePropertyMeetingNoteModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.meetingNoteTitle = _data["meetingNoteTitle"];
            this.meetingNoteContent = _data["meetingNoteContent"];
        }
    }

    static fromJS(data: any): CreatePropertyMeetingNoteModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyMeetingNoteModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["meetingNoteTitle"] = this.meetingNoteTitle;
        data["meetingNoteContent"] = this.meetingNoteContent;
        return data;
    }
}

export interface ICreatePropertyMeetingNoteModel {
    meetingNoteTitle?: string | undefined;
    meetingNoteContent?: string | undefined;
}

export class ApprovePropertyModel implements IApprovePropertyModel {
    propertyId?: string;
    timeForPostId?: string;

    constructor(data?: IApprovePropertyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.timeForPostId = _data["timeForPostId"];
        }
    }

    static fromJS(data: any): ApprovePropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovePropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["timeForPostId"] = this.timeForPostId;
        return data;
    }
}

export interface IApprovePropertyModel {
    propertyId?: string;
    timeForPostId?: string;
}

export class PaginatedListOfListPropertyModel implements IPaginatedListOfListPropertyModel {
    items?: ListPropertyModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfListPropertyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ListPropertyModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfListPropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfListPropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfListPropertyModel {
    items?: ListPropertyModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SearchingPropertyModel extends PagingIndexModel implements ISearchingPropertyModel {
    propertyKeyWord?: string | undefined;
    propertyTypeId?: string | undefined;
    transactionTypeId?: string | undefined;
    administrativeCode?: string | undefined;
    minPrice?: number | undefined;
    maxPrice?: number | undefined;
    bedroomId?: string | undefined;
    bathroomId?: string | undefined;
    landSize?: number | undefined;
    listedSince?: Date | undefined;
    sortingModel?: SortingPropertyModel | undefined;

    constructor(data?: ISearchingPropertyModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.propertyKeyWord = _data["propertyKeyWord"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.transactionTypeId = _data["transactionTypeId"];
            this.administrativeCode = _data["administrativeCode"];
            this.minPrice = _data["minPrice"];
            this.maxPrice = _data["maxPrice"];
            this.bedroomId = _data["bedroomId"];
            this.bathroomId = _data["bathroomId"];
            this.landSize = _data["landSize"];
            this.listedSince = _data["listedSince"] ? new Date(_data["listedSince"].toString()) : <any>undefined;
            this.sortingModel = _data["sortingModel"] ? SortingPropertyModel.fromJS(_data["sortingModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchingPropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchingPropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyKeyWord"] = this.propertyKeyWord;
        data["propertyTypeId"] = this.propertyTypeId;
        data["transactionTypeId"] = this.transactionTypeId;
        data["administrativeCode"] = this.administrativeCode;
        data["minPrice"] = this.minPrice;
        data["maxPrice"] = this.maxPrice;
        data["bedroomId"] = this.bedroomId;
        data["bathroomId"] = this.bathroomId;
        data["landSize"] = this.landSize;
        data["listedSince"] = this.listedSince ? this.listedSince.toISOString() : <any>undefined;
        data["sortingModel"] = this.sortingModel ? this.sortingModel.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISearchingPropertyModel extends IPagingIndexModel {
    propertyKeyWord?: string | undefined;
    propertyTypeId?: string | undefined;
    transactionTypeId?: string | undefined;
    administrativeCode?: string | undefined;
    minPrice?: number | undefined;
    maxPrice?: number | undefined;
    bedroomId?: string | undefined;
    bathroomId?: string | undefined;
    landSize?: number | undefined;
    listedSince?: Date | undefined;
    sortingModel?: SortingPropertyModel | undefined;
}

export class SortingPropertyModel implements ISortingPropertyModel {
    newest?: boolean | undefined;
    oldest?: boolean | undefined;
    lowestPrice?: boolean | undefined;
    highestPrice?: boolean | undefined;

    constructor(data?: ISortingPropertyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newest = _data["newest"];
            this.oldest = _data["oldest"];
            this.lowestPrice = _data["lowestPrice"];
            this.highestPrice = _data["highestPrice"];
        }
    }

    static fromJS(data: any): SortingPropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new SortingPropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newest"] = this.newest;
        data["oldest"] = this.oldest;
        data["lowestPrice"] = this.lowestPrice;
        data["highestPrice"] = this.highestPrice;
        return data;
    }
}

export interface ISortingPropertyModel {
    newest?: boolean | undefined;
    oldest?: boolean | undefined;
    lowestPrice?: boolean | undefined;
    highestPrice?: boolean | undefined;
}

export class SearchingPropertyForAdminModel extends PagingIndexModel implements ISearchingPropertyForAdminModel {
    propertyNumber?: string | undefined;
    propertyTypeId?: string | undefined;
    transactionTypeId?: string | undefined;
    isApprove?: PropertyApproveStatus | undefined;
    sortingModel?: SortingPropertyModel | undefined;

    constructor(data?: ISearchingPropertyForAdminModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.propertyNumber = _data["propertyNumber"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.transactionTypeId = _data["transactionTypeId"];
            this.isApprove = _data["isApprove"];
            this.sortingModel = _data["sortingModel"] ? SortingPropertyModel.fromJS(_data["sortingModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchingPropertyForAdminModel {
        data = typeof data === 'object' ? data : {};
        let result = new SearchingPropertyForAdminModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyNumber"] = this.propertyNumber;
        data["propertyTypeId"] = this.propertyTypeId;
        data["transactionTypeId"] = this.transactionTypeId;
        data["isApprove"] = this.isApprove;
        data["sortingModel"] = this.sortingModel ? this.sortingModel.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ISearchingPropertyForAdminModel extends IPagingIndexModel {
    propertyNumber?: string | undefined;
    propertyTypeId?: string | undefined;
    transactionTypeId?: string | undefined;
    isApprove?: PropertyApproveStatus | undefined;
    sortingModel?: SortingPropertyModel | undefined;
}

export class SuggestSearchPropertyModel implements ISuggestSearchPropertyModel {
    suggestAdministrative?: SuggestPropertyAdministrativeModel[] | undefined;
    suggestProperty?: SuggestPropertyModel[] | undefined;

    constructor(data?: ISuggestSearchPropertyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["suggestAdministrative"])) {
                this.suggestAdministrative = [] as any;
                for (let item of _data["suggestAdministrative"])
                    this.suggestAdministrative!.push(SuggestPropertyAdministrativeModel.fromJS(item));
            }
            if (Array.isArray(_data["suggestProperty"])) {
                this.suggestProperty = [] as any;
                for (let item of _data["suggestProperty"])
                    this.suggestProperty!.push(SuggestPropertyModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SuggestSearchPropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestSearchPropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.suggestAdministrative)) {
            data["suggestAdministrative"] = [];
            for (let item of this.suggestAdministrative)
                data["suggestAdministrative"].push(item.toJSON());
        }
        if (Array.isArray(this.suggestProperty)) {
            data["suggestProperty"] = [];
            for (let item of this.suggestProperty)
                data["suggestProperty"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISuggestSearchPropertyModel {
    suggestAdministrative?: SuggestPropertyAdministrativeModel[] | undefined;
    suggestProperty?: SuggestPropertyModel[] | undefined;
}

export class SuggestPropertyAdministrativeModel implements ISuggestPropertyAdministrativeModel {
    administrativeCode?: string | undefined;
    administrativeName?: string | undefined;

    constructor(data?: ISuggestPropertyAdministrativeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.administrativeCode = _data["administrativeCode"];
            this.administrativeName = _data["administrativeName"];
        }
    }

    static fromJS(data: any): SuggestPropertyAdministrativeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestPropertyAdministrativeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["administrativeCode"] = this.administrativeCode;
        data["administrativeName"] = this.administrativeName;
        return data;
    }
}

export interface ISuggestPropertyAdministrativeModel {
    administrativeCode?: string | undefined;
    administrativeName?: string | undefined;
}

export class SuggestPropertyModel implements ISuggestPropertyModel {
    propertyId?: string;
    propertyNumber?: string | undefined;
    address?: string | undefined;

    constructor(data?: ISuggestPropertyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.propertyNumber = _data["propertyNumber"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): SuggestPropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestPropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["propertyNumber"] = this.propertyNumber;
        data["address"] = this.address;
        return data;
    }
}

export interface ISuggestPropertyModel {
    propertyId?: string;
    propertyNumber?: string | undefined;
    address?: string | undefined;
}

export class PagingNearestPropertyModel extends PagingIndexModel implements IPagingNearestPropertyModel {
    ids?: string[] | undefined;

    constructor(data?: IPagingNearestPropertyModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): PagingNearestPropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingNearestPropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPagingNearestPropertyModel extends IPagingIndexModel {
    ids?: string[] | undefined;
}

export class PagingPropertyModel extends PagingIndexModel implements IPagingPropertyModel {

    constructor(data?: IPagingPropertyModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PagingPropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingPropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPagingPropertyModel extends IPagingIndexModel {
}

export class CreatePropertyFavoriteModel implements ICreatePropertyFavoriteModel {
    userId?: string;
    propertyId?: string;

    constructor(data?: ICreatePropertyFavoriteModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.propertyId = _data["propertyId"];
        }
    }

    static fromJS(data: any): CreatePropertyFavoriteModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyFavoriteModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["propertyId"] = this.propertyId;
        return data;
    }
}

export interface ICreatePropertyFavoriteModel {
    userId?: string;
    propertyId?: string;
}

export class PagingPropertyFavoriteModel extends PagingIndexModel implements IPagingPropertyFavoriteModel {
    userId?: string;

    constructor(data?: IPagingPropertyFavoriteModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): PagingPropertyFavoriteModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingPropertyFavoriteModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        super.toJSON(data);
        return data;
    }
}

export interface IPagingPropertyFavoriteModel extends IPagingIndexModel {
    userId?: string;
}

export class CreatePropertyHeartModel implements ICreatePropertyHeartModel {
    userId?: string;
    propertyId?: string;

    constructor(data?: ICreatePropertyHeartModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.propertyId = _data["propertyId"];
        }
    }

    static fromJS(data: any): CreatePropertyHeartModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyHeartModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["propertyId"] = this.propertyId;
        return data;
    }
}

export interface ICreatePropertyHeartModel {
    userId?: string;
    propertyId?: string;
}

export class PagingPropertyHeartModel extends PagingIndexModel implements IPagingPropertyHeartModel {
    userId?: string;
    sortingModel?: SortingFavouriteModel | undefined;

    constructor(data?: IPagingPropertyHeartModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
            this.sortingModel = _data["sortingModel"] ? SortingFavouriteModel.fromJS(_data["sortingModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PagingPropertyHeartModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingPropertyHeartModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["sortingModel"] = this.sortingModel ? this.sortingModel.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPagingPropertyHeartModel extends IPagingIndexModel {
    userId?: string;
    sortingModel?: SortingFavouriteModel | undefined;
}

export class SortingFavouriteModel implements ISortingFavouriteModel {
    newest?: boolean | undefined;
    oldest?: boolean | undefined;
    lowestPrice?: boolean | undefined;
    highestPrice?: boolean | undefined;
    oldFavourite?: boolean | undefined;
    newFavourite?: boolean | undefined;

    constructor(data?: ISortingFavouriteModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newest = _data["newest"];
            this.oldest = _data["oldest"];
            this.lowestPrice = _data["lowestPrice"];
            this.highestPrice = _data["highestPrice"];
            this.oldFavourite = _data["oldFavourite"];
            this.newFavourite = _data["newFavourite"];
        }
    }

    static fromJS(data: any): SortingFavouriteModel {
        data = typeof data === 'object' ? data : {};
        let result = new SortingFavouriteModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newest"] = this.newest;
        data["oldest"] = this.oldest;
        data["lowestPrice"] = this.lowestPrice;
        data["highestPrice"] = this.highestPrice;
        data["oldFavourite"] = this.oldFavourite;
        data["newFavourite"] = this.newFavourite;
        return data;
    }
}

export interface ISortingFavouriteModel {
    newest?: boolean | undefined;
    oldest?: boolean | undefined;
    lowestPrice?: boolean | undefined;
    highestPrice?: boolean | undefined;
    oldFavourite?: boolean | undefined;
    newFavourite?: boolean | undefined;
}

export class PaginatedListOfListPropertyHeartModel implements IPaginatedListOfListPropertyHeartModel {
    items?: ListPropertyHeartModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfListPropertyHeartModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ListPropertyHeartModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfListPropertyHeartModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfListPropertyHeartModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfListPropertyHeartModel {
    items?: ListPropertyHeartModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ListPropertyHeartModel implements IListPropertyHeartModel {
    userId?: string;
    propertyId?: string;
    title?: string | undefined;
    propertyNumber?: string | undefined;
    coverImage?: string | undefined;
    coverImageUrl?: string | undefined;
    propertyAddressVi?: string | undefined;
    propertyAddressEn?: string | undefined;
    price?: number | undefined;
    currencyId?: string | undefined;
    currencyName?: string | undefined;
    currencyNotation?: string | undefined;
    transactionTypeId?: string | undefined;
    transactionTypeVi?: string | undefined;
    transactionTypeEn?: string | undefined;
    bedroomId?: string | undefined;
    bedroomVi?: string | undefined;
    bedroomEn?: string | undefined;
    bathroomId?: string | undefined;
    bathroomVi?: string | undefined;
    bathroomEn?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    provinceName?: string | undefined;
    districtName?: string | undefined;
    wardName?: string | undefined;
    coordinatesProvince?: string | undefined;
    coordinatesDistrict?: string | undefined;
    coordinatesWard?: string | undefined;
    location?: string | undefined;
    lotSize?: number | undefined;
    longitude?: string | undefined;
    latitude?: string | undefined;
    isApprove?: PropertyApproveStatus;
    approveStatusName?: string | undefined;
    approveDate?: Date | undefined;
    createTime?: Date;

    constructor(data?: IListPropertyHeartModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.propertyId = _data["propertyId"];
            this.title = _data["title"];
            this.propertyNumber = _data["propertyNumber"];
            this.coverImage = _data["coverImage"];
            this.coverImageUrl = _data["coverImageUrl"];
            this.propertyAddressVi = _data["propertyAddressVi"];
            this.propertyAddressEn = _data["propertyAddressEn"];
            this.price = _data["price"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.currencyNotation = _data["currencyNotation"];
            this.transactionTypeId = _data["transactionTypeId"];
            this.transactionTypeVi = _data["transactionTypeVi"];
            this.transactionTypeEn = _data["transactionTypeEn"];
            this.bedroomId = _data["bedroomId"];
            this.bedroomVi = _data["bedroomVi"];
            this.bedroomEn = _data["bedroomEn"];
            this.bathroomId = _data["bathroomId"];
            this.bathroomVi = _data["bathroomVi"];
            this.bathroomEn = _data["bathroomEn"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.propertyTypeVi = _data["propertyTypeVi"];
            this.propertyTypeEn = _data["propertyTypeEn"];
            this.provinceCode = _data["provinceCode"];
            this.districtCode = _data["districtCode"];
            this.wardCode = _data["wardCode"];
            this.provinceName = _data["provinceName"];
            this.districtName = _data["districtName"];
            this.wardName = _data["wardName"];
            this.coordinatesProvince = _data["coordinatesProvince"];
            this.coordinatesDistrict = _data["coordinatesDistrict"];
            this.coordinatesWard = _data["coordinatesWard"];
            this.location = _data["location"];
            this.lotSize = _data["lotSize"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.isApprove = _data["isApprove"];
            this.approveStatusName = _data["approveStatusName"];
            this.approveDate = _data["approveDate"] ? new Date(_data["approveDate"].toString()) : <any>undefined;
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ListPropertyHeartModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListPropertyHeartModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["propertyId"] = this.propertyId;
        data["title"] = this.title;
        data["propertyNumber"] = this.propertyNumber;
        data["coverImage"] = this.coverImage;
        data["coverImageUrl"] = this.coverImageUrl;
        data["propertyAddressVi"] = this.propertyAddressVi;
        data["propertyAddressEn"] = this.propertyAddressEn;
        data["price"] = this.price;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["currencyNotation"] = this.currencyNotation;
        data["transactionTypeId"] = this.transactionTypeId;
        data["transactionTypeVi"] = this.transactionTypeVi;
        data["transactionTypeEn"] = this.transactionTypeEn;
        data["bedroomId"] = this.bedroomId;
        data["bedroomVi"] = this.bedroomVi;
        data["bedroomEn"] = this.bedroomEn;
        data["bathroomId"] = this.bathroomId;
        data["bathroomVi"] = this.bathroomVi;
        data["bathroomEn"] = this.bathroomEn;
        data["propertyTypeId"] = this.propertyTypeId;
        data["propertyTypeVi"] = this.propertyTypeVi;
        data["propertyTypeEn"] = this.propertyTypeEn;
        data["provinceCode"] = this.provinceCode;
        data["districtCode"] = this.districtCode;
        data["wardCode"] = this.wardCode;
        data["provinceName"] = this.provinceName;
        data["districtName"] = this.districtName;
        data["wardName"] = this.wardName;
        data["coordinatesProvince"] = this.coordinatesProvince;
        data["coordinatesDistrict"] = this.coordinatesDistrict;
        data["coordinatesWard"] = this.coordinatesWard;
        data["location"] = this.location;
        data["lotSize"] = this.lotSize;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["isApprove"] = this.isApprove;
        data["approveStatusName"] = this.approveStatusName;
        data["approveDate"] = this.approveDate ? this.approveDate.toISOString() : <any>undefined;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IListPropertyHeartModel {
    userId?: string;
    propertyId?: string;
    title?: string | undefined;
    propertyNumber?: string | undefined;
    coverImage?: string | undefined;
    coverImageUrl?: string | undefined;
    propertyAddressVi?: string | undefined;
    propertyAddressEn?: string | undefined;
    price?: number | undefined;
    currencyId?: string | undefined;
    currencyName?: string | undefined;
    currencyNotation?: string | undefined;
    transactionTypeId?: string | undefined;
    transactionTypeVi?: string | undefined;
    transactionTypeEn?: string | undefined;
    bedroomId?: string | undefined;
    bedroomVi?: string | undefined;
    bedroomEn?: string | undefined;
    bathroomId?: string | undefined;
    bathroomVi?: string | undefined;
    bathroomEn?: string | undefined;
    propertyTypeId?: string | undefined;
    propertyTypeVi?: string | undefined;
    propertyTypeEn?: string | undefined;
    provinceCode?: string | undefined;
    districtCode?: string | undefined;
    wardCode?: string | undefined;
    provinceName?: string | undefined;
    districtName?: string | undefined;
    wardName?: string | undefined;
    coordinatesProvince?: string | undefined;
    coordinatesDistrict?: string | undefined;
    coordinatesWard?: string | undefined;
    location?: string | undefined;
    lotSize?: number | undefined;
    longitude?: string | undefined;
    latitude?: string | undefined;
    isApprove?: PropertyApproveStatus;
    approveStatusName?: string | undefined;
    approveDate?: Date | undefined;
    createTime?: Date;
}

export class PropertyMeetingNoteModel extends AuditableModel implements IPropertyMeetingNoteModel {
    id?: string;
    meetingNoteTitle?: string | undefined;
    meetingNoteContent?: string | undefined;
    propertyId?: string;

    constructor(data?: IPropertyMeetingNoteModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.meetingNoteTitle = _data["meetingNoteTitle"];
            this.meetingNoteContent = _data["meetingNoteContent"];
            this.propertyId = _data["propertyId"];
        }
    }

    static fromJS(data: any): PropertyMeetingNoteModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyMeetingNoteModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["meetingNoteTitle"] = this.meetingNoteTitle;
        data["meetingNoteContent"] = this.meetingNoteContent;
        data["propertyId"] = this.propertyId;
        super.toJSON(data);
        return data;
    }
}

export interface IPropertyMeetingNoteModel extends IAuditableModel {
    id?: string;
    meetingNoteTitle?: string | undefined;
    meetingNoteContent?: string | undefined;
    propertyId?: string;
}

export class CreatePropertyNearestModel implements ICreatePropertyNearestModel {
    userId?: string;
    propertyId?: string;

    constructor(data?: ICreatePropertyNearestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.propertyId = _data["propertyId"];
        }
    }

    static fromJS(data: any): CreatePropertyNearestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyNearestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["propertyId"] = this.propertyId;
        return data;
    }
}

export interface ICreatePropertyNearestModel {
    userId?: string;
    propertyId?: string;
}

export class PagingPropertyNearestModel extends PagingIndexModel implements IPagingPropertyNearestModel {
    userId?: string;

    constructor(data?: IPagingPropertyNearestModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): PagingPropertyNearestModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingPropertyNearestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        super.toJSON(data);
        return data;
    }
}

export interface IPagingPropertyNearestModel extends IPagingIndexModel {
    userId?: string;
}

export class UpdateProfileInformationModel implements IUpdateProfileInformationModel {
    userId?: string;
    avatar?: string | undefined;
    avatarUrl?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    address?: string | undefined;
    descriptions?: string | undefined;
    birthDay?: Date;
    genderType?: GenderType;
    agency?: string | undefined;
    license?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    socialNetworks?: CreateSocialNetworkUserModel[] | undefined;

    constructor(data?: IUpdateProfileInformationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.avatar = _data["avatar"];
            this.avatarUrl = _data["avatarUrl"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber1 = _data["phoneNumber1"];
            this.phoneNumber2 = _data["phoneNumber2"];
            this.phoneNumber3 = _data["phoneNumber3"];
            this.address = _data["address"];
            this.descriptions = _data["descriptions"];
            this.birthDay = _data["birthDay"] ? new Date(_data["birthDay"].toString()) : <any>undefined;
            this.genderType = _data["genderType"];
            this.agency = _data["agency"];
            this.license = _data["license"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            if (Array.isArray(_data["socialNetworks"])) {
                this.socialNetworks = [] as any;
                for (let item of _data["socialNetworks"])
                    this.socialNetworks!.push(CreateSocialNetworkUserModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateProfileInformationModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileInformationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["avatar"] = this.avatar;
        data["avatarUrl"] = this.avatarUrl;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber1"] = this.phoneNumber1;
        data["phoneNumber2"] = this.phoneNumber2;
        data["phoneNumber3"] = this.phoneNumber3;
        data["address"] = this.address;
        data["descriptions"] = this.descriptions;
        data["birthDay"] = this.birthDay ? this.birthDay.toISOString() : <any>undefined;
        data["genderType"] = this.genderType;
        data["agency"] = this.agency;
        data["license"] = this.license;
        data["userName"] = this.userName;
        data["email"] = this.email;
        if (Array.isArray(this.socialNetworks)) {
            data["socialNetworks"] = [];
            for (let item of this.socialNetworks)
                data["socialNetworks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateProfileInformationModel {
    userId?: string;
    avatar?: string | undefined;
    avatarUrl?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    address?: string | undefined;
    descriptions?: string | undefined;
    birthDay?: Date;
    genderType?: GenderType;
    agency?: string | undefined;
    license?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    socialNetworks?: CreateSocialNetworkUserModel[] | undefined;
}

export class CreateSocialNetworkUserModel implements ICreateSocialNetworkUserModel {
    socialNetworkId?: string;

    constructor(data?: ICreateSocialNetworkUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.socialNetworkId = _data["socialNetworkId"];
        }
    }

    static fromJS(data: any): CreateSocialNetworkUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSocialNetworkUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["socialNetworkId"] = this.socialNetworkId;
        return data;
    }
}

export interface ICreateSocialNetworkUserModel {
    socialNetworkId?: string;
}

export class PaginatedListOfProfileInformationModel implements IPaginatedListOfProfileInformationModel {
    items?: ProfileInformationModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProfileInformationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProfileInformationModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProfileInformationModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProfileInformationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProfileInformationModel {
    items?: ProfileInformationModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PagingSellerModel extends PagingIndexModel implements IPagingSellerModel {

    constructor(data?: IPagingSellerModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PagingSellerModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingSellerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPagingSellerModel extends IPagingIndexModel {
}

export class CreateSocialNetworkModel implements ICreateSocialNetworkModel {
    appName?: string | undefined;
    iCon?: string | undefined;
    descriptions?: string | undefined;

    constructor(data?: ICreateSocialNetworkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appName = _data["appName"];
            this.iCon = _data["iCon"];
            this.descriptions = _data["descriptions"];
        }
    }

    static fromJS(data: any): CreateSocialNetworkModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSocialNetworkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appName"] = this.appName;
        data["iCon"] = this.iCon;
        data["descriptions"] = this.descriptions;
        return data;
    }
}

export interface ICreateSocialNetworkModel {
    appName?: string | undefined;
    iCon?: string | undefined;
    descriptions?: string | undefined;
}

export class SocialNetworkModel extends AuditableModel implements ISocialNetworkModel {
    id?: string;
    appName?: string | undefined;
    iCon?: string | undefined;
    descriptions?: string | undefined;
    iConUrl?: string | undefined;

    constructor(data?: ISocialNetworkModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.appName = _data["appName"];
            this.iCon = _data["iCon"];
            this.descriptions = _data["descriptions"];
            this.iConUrl = _data["iConUrl"];
        }
    }

    static fromJS(data: any): SocialNetworkModel {
        data = typeof data === 'object' ? data : {};
        let result = new SocialNetworkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appName"] = this.appName;
        data["iCon"] = this.iCon;
        data["descriptions"] = this.descriptions;
        data["iConUrl"] = this.iConUrl;
        super.toJSON(data);
        return data;
    }
}

export interface ISocialNetworkModel extends IAuditableModel {
    id?: string;
    appName?: string | undefined;
    iCon?: string | undefined;
    descriptions?: string | undefined;
    iConUrl?: string | undefined;
}

export class PaginatedListOfSocialNetworkModel implements IPaginatedListOfSocialNetworkModel {
    items?: SocialNetworkModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfSocialNetworkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SocialNetworkModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfSocialNetworkModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfSocialNetworkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfSocialNetworkModel {
    items?: SocialNetworkModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PagingSocialNetworkModel extends PagingIndexModel implements IPagingSocialNetworkModel {

    constructor(data?: IPagingSocialNetworkModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PagingSocialNetworkModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingSocialNetworkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPagingSocialNetworkModel extends IPagingIndexModel {
}

export class PagingSupplierModel extends PagingIndexModel implements IPagingSupplierModel {

    constructor(data?: IPagingSupplierModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PagingSupplierModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingSupplierModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPagingSupplierModel extends IPagingIndexModel {
}

export class CreateTimeForPostModel implements ICreateTimeForPostModel {
    value?: number | undefined;
    displayName?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateTimeForPostModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateTimeForPostModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTimeForPostModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateTimeForPostModel {
    value?: number | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
}

export class TimeForPostModel extends AuditableModel implements ITimeForPostModel {
    id?: string;
    value?: number | undefined;
    displayName?: string | undefined;
    description?: string | undefined;

    constructor(data?: ITimeForPostModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TimeForPostModel {
        data = typeof data === 'object' ? data : {};
        let result = new TimeForPostModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        super.toJSON(data);
        return data;
    }
}

export interface ITimeForPostModel extends IAuditableModel {
    id?: string;
    value?: number | undefined;
    displayName?: string | undefined;
    description?: string | undefined;
}

export class PaginatedListOfTimeForPostModel implements IPaginatedListOfTimeForPostModel {
    items?: TimeForPostModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTimeForPostModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TimeForPostModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTimeForPostModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTimeForPostModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTimeForPostModel {
    items?: TimeForPostModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PagingTimeForPostModel extends PagingIndexModel implements IPagingTimeForPostModel {

    constructor(data?: IPagingTimeForPostModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PagingTimeForPostModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagingTimeForPostModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IPagingTimeForPostModel extends IPagingIndexModel {
}

export class IdentityResult implements IIdentityResult {
    userName?: string | undefined;
    roles?: string[] | undefined;
    email?: string | undefined;
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    succeeded?: boolean;
    errorMessage?: string | undefined;
    userStatus?: UserStatus;

    constructor(data?: IIdentityResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.email = _data["email"];
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.succeeded = _data["succeeded"];
            this.errorMessage = _data["errorMessage"];
            this.userStatus = _data["userStatus"];
        }
    }

    static fromJS(data: any): IdentityResult {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["email"] = this.email;
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["succeeded"] = this.succeeded;
        data["errorMessage"] = this.errorMessage;
        data["userStatus"] = this.userStatus;
        return data;
    }
}

export interface IIdentityResult {
    userName?: string | undefined;
    roles?: string[] | undefined;
    email?: string | undefined;
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    succeeded?: boolean;
    errorMessage?: string | undefined;
    userStatus?: UserStatus;
}

export enum UserStatus {
    LoginFailed = 0,
    LoginSucceeded = 1,
    LockedUser = 2,
    MustChangePassword = 3,
}

export class LoginUserModel implements ILoginUserModel {
    email!: string;
    password!: string;
    rememberMe?: boolean;

    constructor(data?: ILoginUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginUserModel {
    email: string;
    password: string;
    rememberMe?: boolean;
}

export class RefreshTokenModel implements IRefreshTokenModel {
    refreshToken!: string;
    userName!: string;

    constructor(data?: IRefreshTokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): RefreshTokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IRefreshTokenModel {
    refreshToken: string;
    userName: string;
}

export class VerifyAccountModel implements IVerifyAccountModel {
    email!: string;
    token!: string;

    constructor(data?: IVerifyAccountModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): VerifyAccountModel {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyAccountModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["token"] = this.token;
        return data;
    }
}

export interface IVerifyAccountModel {
    email: string;
    token: string;
}

export class ResetPasswordModel implements IResetPasswordModel {
    email!: string;
    token!: string;
    newPassword!: string;

    constructor(data?: IResetPasswordModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.token = _data["token"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["token"] = this.token;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordModel {
    email: string;
    token: string;
    newPassword: string;
}

export class RegisterModel implements IRegisterModel {
    email!: string;
    userName!: string;
    password!: string;
    avatar?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    descriptions?: string | undefined;
    genderType?: GenderType;
    role?: RoleTypes;
    socialNetworks?: CreateSocialNetworkUserModel[] | undefined;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.avatar = _data["avatar"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber1 = _data["phoneNumber1"];
            this.phoneNumber2 = _data["phoneNumber2"];
            this.phoneNumber3 = _data["phoneNumber3"];
            this.descriptions = _data["descriptions"];
            this.genderType = _data["genderType"];
            this.role = _data["role"];
            if (Array.isArray(_data["socialNetworks"])) {
                this.socialNetworks = [] as any;
                for (let item of _data["socialNetworks"])
                    this.socialNetworks!.push(CreateSocialNetworkUserModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["avatar"] = this.avatar;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber1"] = this.phoneNumber1;
        data["phoneNumber2"] = this.phoneNumber2;
        data["phoneNumber3"] = this.phoneNumber3;
        data["descriptions"] = this.descriptions;
        data["genderType"] = this.genderType;
        data["role"] = this.role;
        if (Array.isArray(this.socialNetworks)) {
            data["socialNetworks"] = [];
            for (let item of this.socialNetworks)
                data["socialNetworks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRegisterModel {
    email: string;
    userName: string;
    password: string;
    avatar?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber1?: string | undefined;
    phoneNumber2?: string | undefined;
    phoneNumber3?: string | undefined;
    descriptions?: string | undefined;
    genderType?: GenderType;
    role?: RoleTypes;
    socialNetworks?: CreateSocialNetworkUserModel[] | undefined;
}

export enum RoleTypes {
    SystemAdministrator = 1,
    InternalUser = 2,
    LocalService = 3,
    Seller = 4,
    Guest = 5,
}

export class CreateUserSavedSearchModel implements ICreateUserSavedSearchModel {
    name?: string | undefined;
    keyword?: string | undefined;
    type?: string | undefined;

    constructor(data?: ICreateUserSavedSearchModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.keyword = _data["keyword"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateUserSavedSearchModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserSavedSearchModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["keyword"] = this.keyword;
        data["type"] = this.type;
        return data;
    }
}

export interface ICreateUserSavedSearchModel {
    name?: string | undefined;
    keyword?: string | undefined;
    type?: string | undefined;
}

export class SortingUserSavedSearchModel implements ISortingUserSavedSearchModel {
    pageNumber?: number;
    pageSize?: number;
    newest?: boolean | undefined;
    oldest?: boolean | undefined;
    nameOrder?: boolean | undefined;
    nameOrderDescending?: boolean | undefined;

    constructor(data?: ISortingUserSavedSearchModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.newest = _data["newest"];
            this.oldest = _data["oldest"];
            this.nameOrder = _data["nameOrder"];
            this.nameOrderDescending = _data["nameOrderDescending"];
        }
    }

    static fromJS(data: any): SortingUserSavedSearchModel {
        data = typeof data === 'object' ? data : {};
        let result = new SortingUserSavedSearchModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["newest"] = this.newest;
        data["oldest"] = this.oldest;
        data["nameOrder"] = this.nameOrder;
        data["nameOrderDescending"] = this.nameOrderDescending;
        return data;
    }
}

export interface ISortingUserSavedSearchModel {
    pageNumber?: number;
    pageSize?: number;
    newest?: boolean | undefined;
    oldest?: boolean | undefined;
    nameOrder?: boolean | undefined;
    nameOrderDescending?: boolean | undefined;
}

export class PaginatedListOfUserSavedSearchModel implements IPaginatedListOfUserSavedSearchModel {
    items?: UserSavedSearchModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfUserSavedSearchModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserSavedSearchModel.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfUserSavedSearchModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfUserSavedSearchModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfUserSavedSearchModel {
    items?: UserSavedSearchModel[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class UserSavedSearchModel implements IUserSavedSearchModel {
    id?: string;
    userId?: string;
    name?: string | undefined;
    keyword?: string | undefined;
    type?: string | undefined;
    createTime?: Date;
    numberOfDaysAgo?: number;

    constructor(data?: IUserSavedSearchModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.keyword = _data["keyword"];
            this.type = _data["type"];
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>undefined;
            this.numberOfDaysAgo = _data["numberOfDaysAgo"];
        }
    }

    static fromJS(data: any): UserSavedSearchModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserSavedSearchModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["keyword"] = this.keyword;
        data["type"] = this.type;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["numberOfDaysAgo"] = this.numberOfDaysAgo;
        return data;
    }
}

export interface IUserSavedSearchModel {
    id?: string;
    userId?: string;
    name?: string | undefined;
    keyword?: string | undefined;
    type?: string | undefined;
    createTime?: Date;
    numberOfDaysAgo?: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}